PROJECT HEADER
---------------

Welcome to Project 64 Reloaded!

The goal of Project 64 is to preserve Commodore 64 related documents in
electronic text format that might otherwise cease to exist with the rapid
advancement of computer technology and declining interest in 8- bit computers
on the part of the general population. Project 64 Reloaded maintains a
publicly available, revision controlled repository of all the documents it
took over from the original Project 64. At the time of writing, the
repository is hosted by GitHub and made available to the public under
following URL:

https://github.com/Project-64/reloaded

a simplified interface to the documents is at the time of writing available
under

http://e4aws.silverdr.com/project64/

Project accepts donations, which are meant to help keeping project members
motivated as well as fund project related purchases:

* copies of books or documents
* processing equipment (high quality automated scanner, binding equipment)
* processing software (Commercial OCR/extensions)
* professional services (unbinding, restoration, rebinding)

At the time of writing donations are accepted in the form of electronic
currency:

http://e4aws.silverdr.com/resources/bitcoin/QRproject64donation.png

or as direct donations/sponsorship of the above listed. For direct donations,
please contact project members through project web pages.


DISCLAIMERS
---------------

Extensive efforts were made to preserve the contents of the original
document. However, certain portions, such as diagrams, program listings, and
indexes may have been either altered or sacrificed due to the limitations of
plain vanilla text. Diagrams may have been eliminated where ASCII-art was not
feasible. Program listings may be missing display codes where substitutions
were not possible. Tables of contents and indexes may have been changed from
page number references to section number references. Please accept our
apologies for these limitations, alterations, and possible omissions.

The author(s) of the original document and members of Project 64 make no
representations about the accuracy or suitability of this material for any
purpose. This etext is provided "as-is". Please refer to the warantee of the
original document, if any, that may be included in this etext. No other
warantees, express or implied, are made to you as to the etext or any medium
it may be on. Neither the author(s) nor the members of Project 64 will assume
liability for damages either from the direct or indirect use of this etext or
from the distribution of or modification to this etext. Therefore if you read
this document or use the information herein you do so at your own risk.


DOCUMENT HEADER
---------------

The Project 64 Reloaded etext of Inside Commodore DOS by Richard Immers,
Ph.D. and Gerald G. Neufeld, Ph.D. second edition. Converted to etext by
Silver Dream ! and Pinacolada64.

INCDOS01.TXT (WIP), April 2014


DOCUMENT NOTES
---------------

The following elements specifically and purposefully do not follow the
formatting of the original book:

* Notes - the original notes begin with "NOTE:" and are either fully or
  partially italicised. We don't always follow this for the sake of plain
  text readibility.
* Fixed width - lines printed in fixed width font in the original book are
  left-flush justified. When read as text/plain, you'll see them four spaces
  to the right for Markdown compatibility.
* Chapter headers and titles are formatted in one line rather than two.
* Chapter and section header lines are prepended with "#" marks
* Program listings originally formatted for 40 columns are reformatted to
  full lines wherever possible for better readability and easier processing

---
﻿
                                  INSIDE
                                COMMODORE
                                   DOS
﻿
﻿



                                  INSIDE
                                COMMODORE
                                   DOS

                                    by

                           Richard Immers, Ph.D.
                           Adrian Public Schools
                             Adrian, Michigan

                                   and

                         Gerald G. Neufeld, Ph.D.
                           Brandon University
                            Brandon, Manitoba
                                 Canada


                        Technical Illustrations by
                            Diane M. Corralejo

                               DATAMOST, Inc.
                19821 Nordhoff Street, Northridge, CA 91324
                              (818) 709-1202
﻿



                        First Printing, July 1984
                      Second Printing, February 1985











                           ISBN 0-88190-366-3

                    Copyright © 1984 by DATAMOST, Inc.
                           All Rights Reserved

This manual is published and copyrighted by DATAMOST, Inc. All rights are
reserved by DATAMOST, Inc. Copying, duplicating, selling or otherwise
distributing this product is hereby expressly forbidden except by prior
written consent of DATAMOST, Inc.

The words COMMODORE, CBM, COMMODORE 64, VIC-20, VIC-1541 and the Commodore
logo are registered trademarks of Commodore Business Machines, Inc.

Commodore Business Machines was not in any way involved in the writing or
other preparation of this manual, nor were the facts presented here reviewed
for accuracy by them.

The information presented in this manual is the result of intensive study of
the disassembly of the 1541 DOS. Every effort has been made to provide
error-free information. However, neither the authors nor DATAMOST, Inc. can
accept responsibility for any loss or damage, tangible or intangible,
resulting from use or improper or unintended use of this information.

                                                       Printed in U.S.A.
﻿


                        ACKNOWLEDGEMENTS

A manual like this one would not be possible without a great deal of
technical assistance. Mike Todd's Disk File column in the *ICPUG Newsletter*
proved to be an invaluable source of insight into the inner workings of
Commodore's DOS. Raeto West's book, *Programming the PET/CBM*, was a constant
companion. Jim Butterfield's numerous articles also provided valuable bits
and pieces of information. Brad Templeton's POWER™ system and PAL™ assembler
made the development of the programs in this manual a real joy. These
packages are commercially available from Professional Software Inc. In
addition, both the PAL disassembler and MICROMON were used as tools for
disassembling the 1541 DOS.

We would also like to acknowledge the patience and forebearance of our
families and friends. Without their support, producing this manual would have
been considerably more difficult. Mike Louder of DATAMOST, Inc. also provided
tremendous support for its production.

Finally, we would like to extend a special note of thanks to Dr. Tom MacNeil
and Nancy Neufeld for their diligent work in proofreading this manual.

This manual was written on a Commodore computer system using the WordPro 4
Plus word processing system. The WordPro Plus™ Series is commercially
available from Professional Software Inc. This sophisticated word processing
system made editing and last minute revisions much easier.
﻿
﻿



                        TABLE OF CONTENTS

    Chapter 1 - INTRODUCTION
                A Brief Word About the Programs
                How to Type in the Programs

    Chapter 2 - USING THE 1541'S DOS
                The Purpose of DOS
                Communicating with the 1541
                The Command Channel
                Using the Command Channel
                Diskette Housekeeping

    Chapter 3 - DISKETTE FORMATTING
                Layout of Tracks and Sectors
                Layout of a Sector
                The Header Block
                The Data Block

    Chapter 4 - DISKETTE ORGANIZATION
                Information Management
                The Directory You See
                The Block Availability Map
                The Directory Entries
                Program File Storage
                Sequential File Storage
                Relative File Storage
                User File Storage
                Deleted File Storage
                Locked Files

    Chapter 5 - DIRECT-ACCESS PROGRAMMING
                Introduction to Direct-Access Programming
                Beginning Direct-Access Programming
                Block-Read Command
                Buffer-Pointer Command
                Block-Write Command
                Memory-Read Command
                Memory-Write Command
                Block-Allocate Command
                Block-Free Command
                Memory-Execute Command
                Block Execute Command
                Direct-Access Entomology

    Chapter 6 - INTERMEDIATE DIRECT-ACCESS PROGRAMMING

    Chapter 7 - DOS PROTECTION
                Commodore's Data Encoding Scheme
                Checksums
                Description of DOS Error Messages
                Analyzing a Protected Diskette
                Duplicating a Protection Scheme
                How to Create 21 Errors on a Full Track
                How to Create a 21 Error on a Single Sector
                How to Create a 23 Error on a Single Sector
                How to Duplicate a 23 Error on a Single Sector
                How to Create 23 Errors on a Full Track
                How to Create 20 Errors on a Full Track
                How to Create 27 Errors on a Full Track
                How to Create a 22 Error on a Single Sector
                How to Duplicate a 22 Error on a Single Sector
                How to Format a Diskette with Multiple IDs
                How to Backup a DOS Protected Diskette
                How to Copy a File

    Chapter 8 - GETTING OUT OF TROUBLE
                Unscratching a File
                Recovering a Soft Sector
                Recovering a Hard Sector
                Recovering a Relative File
                Recovering an Entire Diskette
                Recovering a Physically Damaged Diskette
                Recovering an Unclosed File
                Recovering from a Short New
                Recovering from a Full New

    Chapter 9 - OVERVIEW OF THE 1541 DOS
                Introduction to 1541 DOS
                The Hard Working 6502
                Major IP Routines
                Using the IP Routines
                Major FDC Routines
                Using the FDC Routines
                The Recording Process
                Block Diagram of the 1541
                Writing Data to a Diskette
                Reading Data From a Diskette
                Summary Bugs in DOS 2.6
                Write Incompatibility with 4040
                Late News

    Appendix A - 1541 RAM VARIABLE DEFINITIONS

    Appendix B - ANALYSIS OF THE 1541's ROM

    Appendix C - PROGRAM LISTINGS

    Appendix D - MATHEMATICAL CONVERSION ROUTINES

    Index
﻿
                    *Ignorance is a precious thing.*
                 *Once lost, it can never be regained.*
﻿
# CHAPTER 1 - INTRODUCTION

This manual is intended to supplement the documentation provided in the *1541
User's Manual*. Although this manual is primarily designed to meet the needs
of the intermediate to advanced programmer, it will also be of interest to
the novice Commodore user who wants to know more about how his 1541 disk
drive works. This manual is not intended to replace the documentation
provided by Commodore Business Machines, Inc. and the reader is assumed to be
relatively familiar with the contents of the *1541 User's Manual*. For the
sake of continuity and clarity, some of the information covered in the *1541
User's Manual* is also presented here. However, the majority of the
information presented in this manual is original and is the result of
intensive disassembly and annotation of the 1541's DOS by the authors. Some
information is based on articles and notes published in a variety of
publications as well as discussions with other knowledgeable disk experts.

This manual was not prepared with the assistance of Commodore Business
Machines, Inc. Although we cannot guarantee the accuracy of all the
information presented in this manual, the material has been thoroughly
researched and tested.

There were several reasons for writing *Inside Commodore DOS:*

1. To correct errors and omissions in the *1541 User's Manual.*
2. To help you make more effective use of your disk drive.
3. To provide complete information on diskette formatting.
4. To provide complete information on the storage of files.
5. To allow you to read and write data in non-standard ways.
6. To help you make a backup copy of your "protected" diskettes.
7. To help you recover damaged diskettes.
8. To help you understand the operation of your disk drive.

Although this manual focuses primarily on the 1541 disk drive, much of the
information also applies to other Commodore disk drives.



## 1.1 A Brief Word About the Programs

This book contains listings for 46 ready-to-use programs written in BASIC.
These programs are copyrighted. They may NOT be used commercially, in whole
or in part, period. Since many of the programs are long, typing them all in
would be a time consuming, tedious task. Feel free to share your typing
efforts with a friend who has also purchased a copy of this book. In return,
we simply ask that you do not share a program with someone who does not own a
legitimate copy of this book.

The programs in this book are disk utilities. They do not use flashy graphics
or sound. Rather, they are extremely powerful tools. Remember, any tool can
be dangerous if it is used improperly. Be sure that you know what you are
doing before you use a given program. Always experiment with a program on a
test diskette before you actually use it on one that contains valuable
programs or data. Practice makes perfect.

Each program was individually tested on a variety of 1541 disk drives having
a wide range of serial numbers. Moreover, each program always worked
perfectly. Unfortunately, it is impossible to guarantee that a particular
program will work with your model. If a given program does not seem to work
properly, check your typing carefully. Any errors, especially in the DATA
statements which contain a machine language program, will produce problems.

As a courtesy to the more advanced programmer, we have also included the
source listings for each machine language routine A source listing
immediately follows a related BASIC program listing and has a file name
ending in ".PAL". It is for use with the PAL assembler. *Note: If you are
using a different assembler, you may have to make some minor changes.*

The programs in this book were designed to be not only useful and beneficial,
but instructive as well. Many of them illustrate the "state of the art" in
the use of Commodore's direct-access disk commands. Enjoy!



## 1.2 How to Type in the Programs

Program listings in books and magazines often suffer from two problems:
typographical errors that occur when the program is retyped into a word
processor and the readability of Commodore's control characters (e.g., the
reverse field heart that means Clear Screen). To overcome these problems, the
program listings for this book were created using a special "lister" program.
This lister program took a working BASIC program and converted it into a
WordPro™ file. At the same time, control characters were spelled out in words
and surrounded by curly brackets. For example, a reverse field heart was
converted to {CLR}. The table below summarizes the listing conventions, the
corresponding control characters, and the proper key/keys to press on your
C64 or VIC-20.

    When You See          What It Represents      What You Type
    ----------------      --------------------    --------------
    {CLR}                 Clear Screen            Hold down SHIFT and press
                                                  CLR/HOME
    {HOME}                Home Cursor             Press CLR/HOME
    {DOWN}                Cursor Down             Press CRSR/DOWN
    {UP}                  Cursor Up               Hold down SHIFT and press
                                                  CRSR/UP
    {RIGHT}               Cursor Right            Press CRSR/RIGHT
    {LEFT}                Cursor Left             Hold down SHIFT and press
                                                  CRSR/LEFT
    {RVS}                 Reverse Field ON        Hold down CTRL and press 9
    {ROFF}                Reverse Field OFF       Hold down CTRL and press 0

NOTE 1: When a number appears inside the curly brackets, it means you repeat
the control character immediately to the left of the number that many times.
For example:

{DOWN 5} means to press CRSR/DOWN five (5) times.

NOTE 2: All programs have been listed in a column 40 characters wide. Except
where special characters have been spelled out between curly brackets, the
lines are listed exactly as they appear on a Commodore 64 display. Spaces
must be typed in as listed. Where necessary, count the character columns to
determine the appropriate number of spaces.

Happy hunting and pecking!
﻿
﻿
# CHAPTER 2 - USING THE 1541'S DOS

## 2.1 The Purpose of a DOS

A disk operating system (DOS) is a machine language program that controls a
disk drive. It does several different tasks:

1. Handling communications between a disk drive and a computer.
2. Carrying out housekeeping chores such as formatting a diskette.
3. Managing the storage of information on a diskette.
4. Reading and writing information onto a diskette's surface.

In many computer systems, a DOS is loaded into the main computer's memory
from diskette when the computer is first switched on. In this type of system
many of the tasks are carried out using the computer's microprocessor and
RAM. Commodore uses a different approach. All of Commodore's disk drives are
intelligent peripherals. They do not have to use the computer's resources;
they have their own. For example, the 1541 disk drive contains its own 6502
microprocessor, 2K of RAM, two 6522 I/O chips, and a DOS program permanently
stored in 15.8K of ROM.

The advantages of having an intelligent disk drive are:

1. The DOS does not use any of the computer's memory.
2. Some disk operations can be carried out independently from the CPU.
3. Disk operations do not slow down processing.
4. One disk drive can be shared among several computers.

The disadvantages of having an intelligent disk drive are:

1. It is very difficult to customize DOS routines.
2. You must replace the ROMs to convert to a new version of DOS.



## 2.2 Communicating with the 1541

Your Commodore 64 or VIC-20 can communicate with your 1541 disk drive in
several ways:

1. Through the LOAD, SAVE, and VERIFY commands.
2. Through I/O using the command channel.
3. Through I/O using data communication channels.

Let's examine each of these in greater detail.

1. LOAD, SAVE, and VERIFY commands:

These BASIC commands are used to store and retrieve programs on the Commodore
tape and disk drives. They are designed for ease of use, even by the novice.
The BASIC interpreter in the computer interprets these commands and sends the
disk drive the necessary information over the serial bus.

2. I/O using the command channel:

The command channel is used to send messages to the disk drive to carry out
disk operations like: formatting a blank diskette, erasing an unwanted file,
renaming a file, etc. These operations are often referred to as disk
housekeeping. The command channel is also used to input messages, such as the
current error status of the drive, generated by the DOS. For more details on
how to use the command channel, see Section 2.4.

3. I/O using data communication channels:

The 1541 DOS supports a variety of kinds of files: program files, sequential
files, relative files, user files, and direct-access files. The storage and
retrieval of information in files is carried out using a data communication
channel. Although this manual provides detailed information regarding how
files are stored and organized, no attempt is made to teach you how to
develop programs that make extensive use of file handling. We would encourage
readers who are interested in file handling techniques to refer to Jim
Butterfield's series of articles in *COMPUTE!.* The only I/O applications
discussed in this manual are those relating to direct-access programming (see
Chapter 5).

Since the rest of this manual makes extensive use of the command channel,
let's examine it in some detail.



## 2.3 The Command Channel

The command channel (channel number 15) is an important communication link
between your computer and the 1541 disk drive. It has several important
functions. You can use it to:

1. Monitor the error status of the drive to ensure that everything is
operating properly.

2. Send commands that direct the DOS to perform various housekeeping chores
associated with disk handling.

3. Send commands that direct the DOS to read or write information to specific
areas on a diskette.

This chapter focuses on the first two of these uses. Chapter 5 provides more
detail on reading or writing to a diskette.



## 2.4 Using the Command Channel

Using the command channel is easy. Just follow these steps:

1. Establish communications using an OPEN statement.
2. Send commands to the DOS using a PRINT# statement.
3. Read DOS messages using a GET# or INPUT# statement.
4. Close the channel using a CLOSE statement when you are finished.

Let's go over each step to ensure that you know exactly what to do.


### 1. Establishing communications using an OPEN statement.

In order to establish a communication channel between your computer and your
1541 disk drive, you use an OPEN statement. An OPEN statement is a BASIC
command which looks like this:

    SYNTAX:         OPEN file#, device#, channel#
    EXAMPLE:        OPEN 15, 8, 15

where

file#           = the logical file number (1-127)
device#         = the device number (8 for a stock 1541)
channel#        = the channel number or secondary address (2-15)

NOTE:

* Channel numbers 0 & 1 are reserved for use by the DOS.
* Channel numbers 2-14 are data communications channels.
* Channel number 15 is the command channel.

The OPEN statement can be used either in immediate mode (typed and executed
directly from the keyboard) or under program control (embedded in a program).

In the example above (OPEN 15, 8, 15) we opened logical file number 15 on the
C64 to device number 8 (the disk drive) through channel 15 (the command
channel).


### 2. Sending commands to the DOS using a PRINT# statement.

In order to send commands from your computer to the 1541, you use a PRINT#
statement. A PRINT# statement is a BASIC command which looks like this:

    SYNTAX:         PRINT# file#, "command"
    EXAMPLE:        PRINT#15, "N0:MY DISKETTE,MD"

where

* file# = the logical file number you used when you opened the command channel
* command = the disk command to be sent to the DOS

NOTE: The statement is PRINT# not PRINT #. You *must not* put a space before
the # sign. Spaces following the # sign are always optional. DO NOT use ?# as
an abbreviation either. The correct abbreviation is pR (p then SHIFTED R).

In this example, the disk command is "N0:MY DISKETTE,MD". This command causes
the DOS to prepare the blank diskette in the drive for first-time use.

Although there are many different disk commands, they fall into two groups:

1. Commands related to disk housekeeping.
2. Commands to read or write data to a diskette or the disk drive's RAM.

The disk housekeeping commands are discussed in the next part of this
chapter. The commands relating to reading or writing data are discussed in
Chapter 5 on Direct-Access Programming.


### 3. Reading DOS messages using a GET# or an INPUT# statement.

You may use either an INPUT# or a GET# statement to read the command channel
and access any messages or data prepared for the computer by the DOS. Both
INPUT# and GET# statements are BASIC commands. They look like this:

    SYNTAX:         INPUT# file#, variable list
                    GET# file#, variable list

    EXAMPLE:        INPUT# 15, EN, EM$, ET, ES
                    GET# 15, A$

where

* file# = the logical file number you used when you opened the command channel
* variable list = one or more variable names separated by commas

NOTE: As was noted for PRINT# above, the BASIC statements are INPUT# and
GET#, not INPUT # and GET #. You *must not* put a space before the # sign.
Spaces following the # sign are always optional. Neither the INPUT# statement
nor the GET# statement can be used in immediate mode (typed and executed
directly from the keyboard). They must be included within a program.

The INPUT# command and the GET# command operate in much the same way as the
more familiar INPUT and GET commands. INPUT# always reads as far as the next
carriage return character while GET# reads a single byte of information.
Generally, GET# is used in direct-access programming and INPUT# is used only
for monitoring the drive's error status as indicated immediately below.

You can check the error status of your disk drive using the command channel.
The DOS monitors every disk operation as it is carried out and prepares a
status report indicating whether or not the operation was completed
successfully. The report consists of an error code number, an English
language message, and the track and sector where the problem, if any, was
encountered. Here is a subroutine that checks the error status.

    100 OPEN 15,8,15 : REM THE OPEN COMMAND CHANNEL
            .       .       .
    500 INPUT#15,EN,EM$,ET,ES : REM INPUT THE ERROR STATUS
    51O IF EN < 20 THEN RETURN : REM NO ERROR ENCOUNTERED
    520 PRINT EN;EM$;ET;ES : REM PRINT THE ERROR STATUS ON SCREEN
    530 CLOSE 15 : END : REM ABORT ON BAD STATUS

Line 100 opens the command channel. It is a good idea to open the command
channel at the beginning of your program and leave it open until the end.
Line 500 inputs the status report. The error code number is stored in EN, the
message in EM$, the track in ET, and the sector in ES. Error codes less than
20 may be ignored (line 510). A complete list of the error codes and messages
is contained in the back of your *1541 User's Manual*. A detailed explanation
of the nature and cause of many of these errors is provided in Chapter 7 on
Disk Protection.


### 4. CLOSE the command channel when you are done.

After you have finished using the command channel, it should be closed.
Recall that the OPEN command has three parameters: the logical file number,
the device number, and the channel number. The CLOSE command has only one,
the logical file number. It looks like this:

    SYNTAX:         CLOSE file#
    EXAMPLE:        CLOSE 15

where

file# = the logical file number you used when you opened the command channel

NOTE: Loading, running, or editing a program closes down all communication
channels automatically. The command channel is closed properly in each
instance. However, data channels are aborted rather than closed. When a data
channel is aborted, the file is NOT CLOSED properly on the disk drive. You do
not have to close the command channel after the issuance of every command. If
you forget to close it, the worst that can happen is a ?FILE OPEN ERROR when
you attempt to open it again. However, you should get into the habit of
always closing a file when you are finished using it. You won't get into
trouble leaving the command channel open, but you may lose an important data
file if you leave a data communication channel open.



## 2.5 Disk Housekeeping

As your collection of programs grows, you will have to do some housekeeping
to keep things in shape. Disk housekeeping chores include the following:

1. Preparing a blank diskette for first-time use.
2. Erasing the contents of a diskette currently in use.
3. Initializing a diskette.
4. Renaming a file.
5. Scratching or erasing a file.
6. Copying a file.

These operations are carried out by the DOS in response to commands sent to
the drive using the command channel as indicated above. Once a disk
housekeeping command is issued, the disk drive will carry out the task
without further intervention by the computer. This means that you could edit
or even RUN a program in RAM while the disk drive busily formats or validates
a diskette. This is not really spooling. It occurs because the 1541 is an
intelligent peripheral. The only thing that will cause your computer to wait
for the disk drive to complete its task is your attempting to perform another
disk operation. This includes closing the command channel.

Let's take a look at the disk commands used for housekeeping. NOTE: If you
are using the DOS SUPPORT program that came on your 1541TEST/DEMO, the syntax
for these disk commands is remarkably shorter. The > or @ keys are used to
send a command to the disk drive. They take the place of the PRINT#
statement. In addition, you do not have to open or close the command channel
or embed the disk command in quotation marks. The DOS SUPPORT program will do
this automatically for you. The DOS 5.1 syntax can be used only in immediate
mode, however. It cannot be used in a program or a ?SYNTAX ERROR will result.


### The New Command

When a fresh diskette is taken from its storage envelope, the 1541 cannot
recognize it. The diskette must be formatted or newed prior to first-time
use. Formatting or newing a diskette is performed by the DOS. The DOS
proceeds to write concentric tracks made up of blocks/sectors to the
diskette. In addition, a directory is set up, wherein the drive records
information about all the files stored on the diskette. Chapter 3 provides a
much more detailed account of this operation. The syntax for formatting a
diskette is really quite simple:

    SYNTAX:         OPEN 15, 8, 15
                    PRINT#15, "N0:DISK NAME,ID"
                    CLOSE 15

    ALTERNATE:      PRINT#15, "N:DISK NAME,ID"

    EXAMPLE:        OPEN 15, 8, 15
                    PRINT#15, "N0:MY DISKETTE,MD"
                    CLOSE 15

    DOS 5.1:        >N0:DISK NAME,ID
                    >N:DISK NAME,ID

The disk command, "N0:MY DISKETTE,MD", is sent to the drive by the PRINT#15
statement. The command has three parameters. The first parameter within
quotes is N0:. The N stands for NEW. The 0 is a holdover from the dual drive
system and indicates which drive. The 0 is optional on the 1541 and may be
omitted. The colon terminates the DOS command. The second parameter is the
disk name. It is limited to 16 characters in length. Generally these are
alphanumeric characters. In the example above, we named the diskette: MY
DISKETTE. The disk name is cosmetic and appears in the directory for
reference purposes only. It is not written anywhere else on the diskette. The
disk name is followed by a comma. The DOS looks or parses for this. After the
comma are two alphanumeric characters for the disk ID. In the above example
we selected MD as our disk identifier. The ID is written to every block or
sector on the diskette. It is impossible to alter. The DOS repeatedly looks
at the ID of a sector to be sure that you have not switched diskettes on it.
Each diskette should be formatted with a unique ID. This will prevent the DOS
from inadvertently overwriting programs on what appears to be an identical
diskette.

A "full" new on a diskette takes roughly 2-3 minutes. There is a quicker way
to erase a diskette that has already been used. This is accomplished by
leaving off the disk ID. For example:

    SYNTAX:         OPEN 15, 8, 15
                    PRINT#15, "N0:DISK NAME"
                    CLOSE 15

    ALTERNATE:      PRINT#15, "N:DISK NAME"

    EXAMPLE:        OPEN 15, 8, 15
                    PRINT#15, "N0:TEST DISKETTE"
                    CLOSE 15

    DOS 5.1:        >NO:DISK NAME
                    >N:DISK NAME

Notice that no comma or ID follows the disk name. This command will work only
on a diskette that has previously been formatted. It is referred to as a
"short" new. A "short" new simply erases the first sector in the directory
and writes an empty BAM (block availability map) to tell the DOS that we have
a fresh diskette in use.

NOTE: A diskette that is plagued by read or write errors does not have to be
pitched. Copy the files to another diskette first. Then do a "full" new on
the offending diskette. This will erase and reformat the entire diskette. A
"short" new rewrites only sectors 0 and 1 of track 18 and will not eliminate
any read or write errors. See Chapter 8 about how to recover from both a
"short" new and a "full" new.


### The Initialize Command

Initialization has nothing to do with formatting. APPLE™ owners format a
diskette by "initializing" it. This is NOT TRUE with Commodore. Initializing
a diskette forces the DOS to read the disk ID and the contents of the BAM and
store them in the drive's internal memory. The BAM establishes where the next
available sector is for writing. Without it files would be overwritten. To
initialize a diskette perform the following:

    SYNTAX:         OPEN 15, 8, 15
                    PRINT#15, "I0"
                    CLOSE 15

    ALTERNATE:      PRINT#15, "I"

    DOS 5.1:        >I0
                    >I

The I is short for INITIALIZE. The drive number can be ignored if you are
using only one 1541. The drive motor purrs for a few seconds and then settles
down. It's that simple. It is a good habit to initialize a diskette each time
you insert it into your 1541 drive. This point cannot be overemphasized. Do
it yourself. Do not rely upon the "autoinit" feature of the drive.
Initialization prevents the DOS from overwriting files in the event that two
diskettes with identical IDs are swapped. The drive cannot tell the
difference between two diskettes with identical IDs since it is the ID that
the DOS uses to identify a diskette. Initialization also assures you that a
diskette is properly seated in the drive before use.

The 1541 drive has a built in autoinitialization feature. Once it encounters
an error it will retry a disk operation several times. Often it can recover
from an error on its own. If it fails, it gives up. Before doing so, though,
it will do a "bump." On a bump the read/write head is stepped outwards 45
tracks (slight overkill) to assure that it is on track 1. The drive clatters
when a protrusion on the stepper motor's drive pulley bumps up against a
mechanical stop. (It really isn't a melt down.) The head then steps inwards
to track 18 and the DOS awaits further instructions. Self initialization
avoids this scenario. Initialize every time you insert a diskette into the
drive.

Initialization clears the error channel and turns off the flashing red LED.
Unless, of course, you are trying to initialize an unformatted diskette or
forgot to put one in the drive to begin with. Clearing the error channel
destroys the error status the DOS prepared for you. If error checking is
important, retrieve the error message first; then initialize the drive.


### The Rename Command

Occasionally you will want to change the name of a file stored on a diskette.
To rename a file you first open the command channel and then send the rename
command like this:

    SYNTAX:         OPEN 15, 8, 15
                    PRINT#15, "R0:NEW NAME=OLD NAME"
                    CLOSE 15

    ALTERNATE:      PRINT#15, "R:NEW NAME=OLD NAME"

    EXAMPLE:        OPEN 15, 8, 15
                    PRINT#15, "R0:DISPLAY T&S=DTS"
                    CLOSE 15

    DOS 5.1:        >R0:NEW NAME=OLD NAME
                    >R:NEW NAME=OLD NAME

Again the syntax is exacting but simple to follow. The R0: means to rename on
drive 0. It is short for RENAME0:. As before, the 0 is optional on the 1541.
The next parameter is the new file name. A file name is generally
alphanumeric in nature and 16 characters are allowed at the maximum. (Commas,
colons, semicolons, and wild cards are not permitted. Cursor control and
reverse video characters should be avoided.) The new file name is followed by
an " = " sign. The last parameter is the existing or old file name. It must
be spelled out exactly as it appears in the directory. Wild cards (*,?) are
not allowed. If you make a typo on this parameter or the file does not appear
in the directory, the rename command fails. No damage is done, so relax. In
the above example our new file name is DISPLAY T&S. It replaces the old file
name DTS. One final point. You cannot rename a file that is currently open
for a read or write.


### The Copy Command

The copy command allows you to easily backup an existing file on your
diskette. There are three restrictions attached. First, the new file must
have a different name. Second, the copy command will not work on a relative
file. Third, you must have enough room on the diskette. The copy command
looks like this:

    SYNTAX:
            OPEN 15, 8, 15
            PRINT#15, "C0:BACKUP=0:ORIGINAL"
            CLOSE 15

    ALTERNATE:
            PRINT#15, "C:BACKUP=ORIGINAL"

    EXAMPLE:
            OPEN 15, 8, 15
            PRINT#15, "C0:MY PROGRAM B/U=0:MY PROGRAM"
            CLOSE 15

    DOS 5.l:
            >C0:BACKUP=0:ORIGINAL
            >C:BACKUP=ORIGINAL

The C is short for COPY. The new file above is called MY PROGRAM B/U. It is a
backup copy of a previous program called MY PROGRAM. Note that we must
specify the drive number twice. Again this is a holdover from a dual drive
configuration. The C does not appear twice, however. The same restrictions
that apply to the rename command are also in effect here, i.e., 16 character
file name limit, use of restricted characters, etc. The drive number is
optional. See the alternate syntax to save a few keystrokes.

It is also possible to merge two or more sequential data files using the copy
command. The syntax for this is as follows:

    SYNTAX:
            OPEN 15, 8, 15
            PRINT#15, "C0:COMBINED=0:FILE1,0:FILE2,0:FILE3"
            CLOSE 15

    ALTERNATE:
            PRINT#15, "C:COMBINED=FILE1,FILE2,FILE3"

    EXAMPLE:
            OPEN 15, 8, 15
            PRINT#15, "C0:MAILFILE=0:NAME,O:ADDRESS,0:CITY"
            CLOSE 15

    DOS 5.l:
            > CO:COMBINED=0:FILE1,0:FILE2,0:FILE3
            >C:COMBINED=FILE1,FILE2,FILE3

Our large file now consists of several files appended together. While this
feature of the copy command is available, it is rarely used. Few programming
techniques would require or ever utilize this feature. Note that this
technique cannot be used to append a subroutine onto a BASIC program; the
subroutine cannot be merged into the main program by the disk drive. You will
need to use a programmer's aid like POWER™, SYSRES™, or BASIC AID™ for the
C64 to do this.


### The Scratch Command

To get rid of an unwanted file, we scratch it. The only exception is an
unclosed file. An unclosed file is one that appears in the directory as
having zero blocks and whose file type is preceded by an asterisk (*SEQ,
*PRG, etc.). This will be explained below. To scratch a file, first remove
the write protect tab and key in:

    SYNTAX:         OPEN 15, 8, 15
                    PRINT#15, "S0:FILE NAME"
                    CLOSE 15

    ALTERNATE:      PRINT#15, "S:FILE NAME"

    EXAMPLE:        OPEN 15, 8, 15
                    PRINT#15, "S0:TESTING 123"
                    CLOSE 15

    DOS 5.1:        >SO:FILE NAME
                    >S:FILE NAME

The scratch command requires a single parameter, the file name, preceded by S
or SCRATCH. As before, the drive number is optional.

There are some variations that incorporate wild cards. Wild cards in a file
name are asterisks (*) or question marks (?). They should be used with utmost
caution since more than one file can be scratched at a time.

    EXAMPLE:        OPEN 15, 8, 15
                    PRINT#15, "S0:T*"
                    CLOSE 15

    DOS 5.1:        >S0:T*

In the above example all files beginning with the letter T, regardless of
file type, will be scratched. In the event that no file starts with the
letter T, none will be affected. Careless use of a wild card can have
catastrophic results. For example:

    EXAMPLE:        OPEN 15, 8, 15
                    PRINT#15, "S0:*"
                    CLOSE 15

    DOS 5.1:        >S0:*

The above command will scratch every file on the diskette. It is the
equivalent of performing a short new on a diskette. Be careful!

The second wild card is the question mark. It is used to mask out characters
that are not of importance. Suppose we want to scratch a number of files
whose names are all eight characters long and end in .C64. We could not use
.C64* to scratch them since the match falls at the end of the file name.
However, we could use:

    EXAMPLE:        OPEN 15, 8, 15
                    PRINT#15, "S0:????.C64"
                    CLOSE 15

    DOS 5.1:        >S0:????.C64

Note that we used four question marks in the above example. An exact match of
.C64 must occur on characters 5 through 8 of the file name. No match — no
scratch. If we had 1541.C64 and C100.C64 on the disk, both would be scratched
by the previous command. However, BACKUP.C64 would not be affected.

More than one wild card can be used within the same command. For example:

    EXAMPLE:        OPEN 15, 8, 15
                    PRINT#15, "S0:T?ST*"
                    CLOSE 15

    DOS 5.1:        >S0:T?ST*

This command would scratch files with these names: TEST, TASTY, TESTING123.
The file TOAST would not be affected. Note that it makes no sense to send a
command like this: "S0:T*ST???". The asterisk has priority over the question
mark. All characters that appear after the asterisk are ignored.

A file type that begins with a * is unclosed: *SEQ, *PRG, etc. It was never
closed properly. This can happen for a variety of reasons:

1. The diskette may have been at its physical capacity and a disk-full
   situation occurred during a save or write to a diskette.

2. A bad sector may have been encountered during a write to a diskette.

3. The file may have been left open following a write operation because you
   forgot to CLOSE the file, or you aborted the program by hitting either the
   RUN/STOP key or the RUN/STOP and the RESTORE keys.

4. Your program had a syntax error in it and the BASIC interpreter returned
   you to immediate mode.

(See Chapter 8 about how to recover an unclosed file.)

Whatever the cause, *an unclosed file should never be scratched!* Since the
write operation was aborted, the internal organization of the diskette (i.e.,
the BAM), has been left in disarray. It does not match the actual file
contents of the diskette. Any further attempt to write to that diskette will
probably cause a loss of one or more files. Files can actually overlap one
another now and you will be left with a poisoned diskette. The DOS does have
a command to decorrupt itself. This is the validate command. When in doubt,
validate your diskette!

The scratch command does not actually erase the file on your diskette. Rather
it traces the file across the surface of the diskette and frees any sectors
the file occupied. The file-type byte is also changed to a zero in the
directory which indicates to the DOS that it is no longer active. *If you
inadvertently scratch a file that you didn't mean to, stop right then and
there!* You can recover it. Do not attempt to write to the diskette. The
sectors just freed will be used on subsequent writes to the diskette. Once
you write to the diskette, recovery is impossible. Chapter 8 on Getting Out
of Trouble shows you how to recover a scratched file.


### The Validate Command

This command tells the DOS to reconstruct its map which shows where
information is stored on the diskette, so it conforms to the files listed in
the directory. This is a simple way to decorrupt a damaged diskette. However,
it is not a failsafe command as will be explained shortly. A validate command
looks like this:

    SYNTAX:         OPEN 15, 8, 15
                    PRINT#15, "V0"
                    CLOSE 15

    ALTERNATE:      PRINT#15, "V"

    DOS 5.1:        >V0
                    >V

The V is an abbreviation for VALIDATE. As before, the 0 is optional for the
1541 drive.

What does a validate do? The DOS keeps a map that indicates which sectors on
a diskette are currently in use. This map is stored on track 18, sector 0. It
is referred to as the Block Availability Map or just the BAM for short. When
the validate command is issued, all blocks are freed in the BAM on the
diskette simulating a newly formatted blank diskette. The drive then picks up
the first file in the directory and chains through the entire file. As
sectors are picked up along the way, they are allocated in the BAM as
currently in use. If the file is traced successfully, all blocks associated
with it are put back into the BAM as in use. The next file is then picked up
out of the directory and the process continues. When all files have been
traced, the new BAM is written to the diskette and the internal count now
matches the directory contents.

So far so good. Now let's see what happens to an unclosed file. When the DOS
encounters an unclosed file in the directory during a validate command, all
it does is change the file type byte in the directory entry to a 0 (scratched
file). No attempt is made to trace the file. When the validate operation is
complete, the unclosed file will no longer appear in a directory listing and
any blocks associated with it will be free. This is what you want to happen.
Now let's see what happens if you attempt to SCRATCH an unclosed file.

When you scratch a file, two things happen: the file-type byte in the
directory for this file is set to 0 (scratched file) and the DOS traces
through the chain of sectors that make up the file and marks each sector it
encounters as available for use (free) in the BAM. This is just what you want
to have happen for a normal file, but it can poison the diskette when you try
it on an unclosed file. Here's why. The last sector of an unclosed file was
never written out to the diskette. As a result, the second to the last sector
points to a sector that is not really part of the file. The DOS doesn't
realize this and continues to follow the "chain." If you are lucky, the
"unwritten sector" will be a empty sector (never used since the disk was
formatted). If this happens, the DOS will stop because pointers point to a
non-existent track and sector (75,1). If you are unlucky, the "unwritten
sector" will be part of a file that you scratched last week and the pointer
will just happen to point into the middle of that very important file you
just saved yesterday. When this happens, the DOS will merrily deallocate the
remaining sectors in your file. The next write operation to the diskette will
see this nice big open space and the new information will be saved right on
top of your active file. Now the situation has gone from bad to worse and is
in fact pathological — hence a poisoned disk. The only solution is to inspect
each file first to ensure that it is not tainted and then copy it onto
another diskette.

The validate routine is aborted if an error (an unreadable sector) is
encountered. When it aborts, nothing radical occurs. The new BAM is not
written to the disk until the validation process has been completed. Don't
worry about the blank BAM getting you in trouble; the DOS will read the old
one back in before it allows you to write to the disk. However, the diskette
still remains corrupted with no quick remedy in sight. Chapter 8 on recovery
deals with this and other disasters.

﻿
﻿
# CHAPTER 3 - DISKETTE FORMATTING

When you take a new floppy diskette out of the package, it is blank. Before
the drive can store data onto it, it must be formatted. This is done by
inserting the diskette into the drive and sending a NEW command to the DOS
(see Section 2.5). During "formatting" or "newing", 35 concentric tracks are
written to the diskette. Each track is made up of varying numbers of
sectors/blocks where programs and data will eventually be stored. In addition
to laying down empty blocks/sectors, the DOS creates a directory and a block
availability map (BAM) and records them on track 18.

This chapter describes the formatting process and the tracks and sectors of a
diskette. Chapter 4 describes the directory and the block availability map
(BAM).



## 3.1 Layout of Tracks and Sectors

During the formatting (newing) process, the DOS divides the diskette into
tracks and sectors. A track is a circular path on the diskette along which
information is stored.

Each track is concentric with the hole in the center of the diskette. There
are a total of 35 tracks numbered from 1 to 35. Track 1 is the outermost
track and track 35 is the innermost track. The read/write head may be
positioned to any given track. The position of track 1 is determined by a
mechanical stop that limits the outward movement of the read/write head. The
other tracks are identified by their distance from track 1. The diagram below
indicates the layout of the tracks on a formatted diskette.

[tracks layout diagram - currently omitted]()

[sectors layout diagram - corrently omitted]()

Although there are only 35 tracks, the stepper motor can position the
read/write head to more than 70 different positions. This might seem to imply
that additional tracks could be recorded on the surface of the diskette to
increase its storage capacity. Unfortunately, the accuracy of the head
positioning mechanism and the width of the path of magnetization produced by
the read/write head makes the use of these "phantom" tracks unreliable. If
you would like to experiment with this, the programs described in Chapter 9
allow you to experiment with stepping the head around.

Each track is divided into seventeen or more sectors (blocks). Each sector
holds 256 bytes of data. (Some manufacturers record data in 512 or 1024 byte
sectors.) Whenever data is read from or written to a diskette, it is done one
complete sector at a time.

On Commodore disk drives, the tracks are not divided into a fixed number of
sectors. The number of sectors depends on the track number. The outer tracks
(lower numbers) are longer and are divided into more sectors than the inner
(higher numbered) tracks. The table below summarizes how the diskette is
organized.

Organization of Tracks and Sectors on a 1541 Formatted Diskette

             Track      Range of Sector    Total Sectors    Total Bytes
    Zone    Numbers        Numbers           Per Track       Per Track
    ----    --------    ---------------    --------------   -----------
     1       1 to 17       0 to 20               21            5376
     2      18 to 24       0 to 18               19            4864
     3      25 to 30       0 to 17               18            4608
     4      31 to 35       0 to 16               17            4352

A total of 683 sectors are written at the time of initial formatting. Since
the disk rotates at a constant speed of 300 rpm, you may wonder how Commodore
manages to vary the number of sectors from zone to zone. This is accomplished
by varying the rate at which data is read or written (changing the clock
rate). Each of the four zones uses a different clock rate. This is
accomplished by using a high speed clock and dividing the clock by N, where
the value of N is determined by the zone. The table below summarizes the
clock rates for each zone.

    Zone    Tracks    Divisor      Clock Rate      Bits/Rotation
    ----   --------   -------   ----------------   -------------
     1      1 to 17     13      307,692 bits/sec     61,538.4
     2     18 to 24     14      285,714 bits/sec     57,142.8
     3     25 to 30     15      266,667 bits/sec     53,333.4
     4     31 to 35     16      250,000 bits/sec     50,000.0

This scheme provides a recording density that varies from about 4000
bits/inch on the outer tracks to almost 6000 bits/inch on the inner tracks.

If all of the possible bits could be used for data alone, we would be able to
store a total of 2,027,676 bits or 253,459 bytes on a diskette.
Unfortunately, not all of these bytes can be used for data. The total storage
capacity of a diskette formatted on the 1541 is 174,848 bytes. The need for
space to store a directory to keep track of the location of the files on a
diskette (see Chapter 4) further reduces us to an effective storage capacity
of 169,984 bytes (256 bytes * 664 sectors).



## 3.2 Layout of a Sector

During the formatting (newing) process, the DOS creates and records onto the
diskette all 683 sectors/blocks that will eventually be used for storing
information. Each sector is comprised of two parts:

1. A header block that identifies the sector.
2. A data block that holds the 256 bytes of data.

The diagram below illustrates how these parts are arranged.

      SECTOR #0                             SECTOR #1
    --------------------------------------------------------
    | |              | |              |#| | |              |
    | | HEADER BLOCK | |   DATA BLOCK |#| | | HEADER BLOCK | --+
    | |              | |              |#| | |              |   |
    --------------------------------------------------------   |
                                                               |
              +------------------------------------------------+
              |
              |                               SECTOR #2   |\
              |   ----------------------------------------- \
              |   | |                |#| | |                 \
              +-->| |   DATA BLOCK   |#| | | HEADER BLOCK     >
                  | |                |#| | |                 /
                  ----------------------------------------| /
                                                          |/
                 ---              ---
                 | |              |#|
                 | | = sync mark  |#| = inter-sec gap
                 | |              |#|
                 ---              ---

The sectors are recorded in numerical sequence along the circular track. Each
sector consists of an identifying header block followed by a data block. The
sectors are separated from each other by an inter-record gap. A special
character called a SYNC MARK is used to mark the beginning of each header or
data block.

A SYNC MARK is a very special character. It consists of 10 or more 1 bits in
a row (normally 40 of them). This particular pattern of bits only occurs at
the start of a header or data block. The hardware in the 1541 drive can
detect this character and signal the DOS that a new data or header block is
coming.

If you are puzzled about why several $FF characters in a row in the data
block are not interpreted as a sync character, you may want to skip ahead to
the section on Commodore's GCR encoding scheme in Chapter 7.



## 3.3 The Header Block

The header block of a sector allows the DOS to identify which track and
sector is being read. It is composed of a sync mark, eight bytes of
identifying information, and a header gap. The diagram below shows the layout
of a header block.

    ------------------------------------------------------------------\
    | SYNC |  HEADER  | HEADER BLOCK | SECTOR | TRACK  | ID CHARACTER  \
    | MARK | BLOCK ID |   CHECKSUM   | NUMBER | NUMBER |   NUMBER 2    / ---+
    -------------------------------------------------------------------\    |
                                                                            |
      +---------------------------------------------------------------------+
      |
      |   \-----------------------------------------------
      +--> \ ID CHARACTER | $0F BYTE | $0F BYTE | HEADER |
           /   NUMBER 1   |          |          |  GAP   |
           \----------------------------------------------

NOTE: The header is recorded on disk exactly as indicated above. The diagram
on page 54 of the *1541 User's Manual* is incorrect.

Let's examine the bytes that make up the header block:

* **Sync Mark:** This consists of 10 or more 1 bits as described above. It
  warns the DOS that either a data block or a header block is coming.

* **Header Block ID:** This is normally a $08 byte. It serves to indicate to
  the DOS that this is a header block and not a data block.

* **Header Block Checksum:** This is a checksum character used by the DOS to
  ensure that the header block was read correctly. It is found by EORing the
  track number, the sector number, and the two ID characters. If you are not
  sure what an EOR is, you may want to read through Section 7.1.

* **Sector Number:** This byte is the number of this particular sector. The
  sectors are numbered consecutively around a track.

* **Track Number:** This byte is the number of this particular track. The DOS
  uses this byte to check to be sure that the record/play head is positioned
  to the correct track.

* **ID Character #2:** This is the second ID character that you specified in
  the NEW command when the diskette was formatted (e.g., the 1 in
  "N0:GAMES,V1"). It is sometimes referred to as the ID HI. The DOS checks
  this byte against a master disk ID to ensure that you have not swapped
  diskettes.

* **ID Character #1:** This is the first ID character that you specified in
  the NEW command when the diskette was formatted (e.g., the V in
  "N0:GAMES,V1"). It is sometimes referred to as the ID LO. The DOS checks
  this byte against a master disk ID to ensure that you have not swapped
  diskettes.

* **$0F Bytes:** These bytes are used as padding (spacing) by the DOS during
  initial formatting. They are called "OFF" bytes. Once formatting is
  complete OFF bytes are never referenced again.

* **Header Gap:** The header gap consists of eight $55 bytes. These eight
  bytes are used to provide breathing room between the header block and the
  data block. The DOS never reads these bytes. They allow the DOS time to
  set-up for reading the data block that follows. NOTE: The 4040 drive uses a
  nine byte header gap. This is one of the reasons why 1541 drives and 4040
  drives are NOT WRITE COMPATIBLE! See Chapter 9 for more information.

NOTE: A header block is written *only* during the formatting process. It is
never rewritten again, period.



## 3.4 The Data Block

The data block of a sector stores the 256 data bytes for this sector. It is
composed of a sync mark, a data block ID character, the 256 bytes of data, a
data block checksum byte, two off bytes, and an inter-sector gap. The diagram
below depicts the layout of a data block.

    -------------------------------------------------------------------
    | SYNC | DATA  |      256       | DATA     | $00  | $00  | INTER- |
    | MARK | BLOCK |   DATA BYTES   | BLOCK    | BYTE | BYTE | SECTOR | --+
    |      | ID    |                | CHECKSUM |      |      | GAP    |   |
    -------------------------------------------------------------------   |
                                                                          |
                               +------------------------------------------+
                               |
                               |                           |\
                               |    ------------------------ \
                               |    |  SYNC |  HEADER |       \
                               +--> |  MARK |  BLOCK  |        >
                                    |       |  ID     |       /
                                    ------------------------ /
                                                           |/

Let's examine the bytes that make up the data block:

* **Sync mark:** This consists of 10 or more 1 bits as previously described.
  It warns the DOS that either a data block or a header block is coming.

* **Data Block ID:** This byte is normally a $07. It serves to indicate to
  the DOS that this is a data block and not a header block ($08).

* **256 Data Bytes:** This is the actual data stored in the sector. See
  Chapter 4 about how Commodore uses the first two bytes as a forward track
  and sector pointer instead of actual data.

* **Data Block Checksum:** This is a checksum character used by the DOS to
  ensure that the data block was read correctly. It is found by EORing all
  256 data bytes together.

* **$00 Bytes:** These two bytes are also called OFF bytes. They are used to
  pad a data block before it is written. They are not referenced again by the
  DOS.

* **Inter-sector Gap:** This is also known as the "tail gap." Its purpose is
  to provide breathing room between the end of the data block and the start
  of the next sector. The length of the gap varies from zone to zone and from
  one drive to another (see the chart in Section 7.1). Between consecutive
  sectors the gap is normally 4 to 12 bytes long. The gap between the last
  sector on a track and sector zero is often longer — up to 100 bytes in
  length. The gap is designed to be long enough so that if you write a data
  block on a day when your drive is turning slightly faster than 300 rpm, you
  won't overwrite the start of the next sector. (Your drive may not be
  turning at exactly 300 rpm all the time because of fluctuations in the
  power supplied to your home or office, mechanical wear, belt slippage,
  changes in temperature, etc.) Note that the DOS never reads these bytes.

The entire data block (including the preceding sync mark) is rewritten each
time data is recorded on a diskette.

This concludes our overview on how a diskette is formatted. Additional
details about how bytes are encoded on the surface of a diskette are provided
in Section 7.1. The actual recording process is described in Section 9.7.

﻿

# CHAPTER 4 - DISKETTE ORGANIZATION

## 4.1 Information Management

The information that is stored on a floppy disk is virtually useless unless
it can be retrieved quickly. As a result, the organization and management of
information is one of the most important tasks of the DOS. To do an efficient
job of management, the DOS must be able to:

1. Keep track of which sectors contain data and which are still empty
(available for use).

2. Assign names and storage locations to large blocks of related information
(files).

3. Keep track of the sequence of sectors that were used to store a file.

The DOS stores most of this information in the directory on track 18, halfway
between the outermost track (1) and the innermost track (35). Centering the
directory serves to minimize head movement across the diskette and extends
the life of both the drive and the media. The directory is subdivided into
two areas—the map showing which sectors are in use and which are free (the
Block Availability Map or BAM) and directory entries. The BAM resides solely
on sector 0 of track 18. It informs the drive as to what sectors are
currently in use and where subsequent writing to the diskette can safely take
place. The remaining sectors (1-18) of track 18 contain directory entries
(file names, file types, and pointers to where files are stored on the
diskette).



## 4.2 The Directory You See

Let's examine the directory of the 1541TEST/DEMO diskette that came with your
drive. Insert it in your drive and type on your keyboard:

    LOAD "$0",8

then type

    LIST

After a brief pause you should see the following on your screen:

    0 "1541TEST/DEMO   " ZX 2A
    13   "HOW TO USE"       PRG
    5    "HOW PART TWO"     PRG
    4    "VIC-20 WEDGE"     PRG
    1    "C-64 WEDGE"       PRG
    4    "DOS 5.1"          PRG
    11   "COPY/ALL"         PRG
    9    "PRINTER TEST"     PRG
    4    "DISK ADDR CHANGE" PRG
    4    "DIR"              PRG
    6    "VIEW BAM"         PRG
    4    "CHECK DISK"       PRG
    14   "DISPLAY T&S"      PRG
    9    "PERFORMANCE TEST" PRG
    5    "SEQUENTIAL FILE"  PRG
    13   "RANDOM FILE"      PRG
    558 BLOCKS FREE.

The 0 refers to which drive was accessed. This is a holdover from the 4040
dual drive system. Next you see the diskette name — 1541TEST/DEMO. In the
event that the diskette name is less than 16 characters in length, blank
spaces are appended to the end of the name. This forced spacing is known as
padding. Following the name of the diskette is the disk ID — ZX in this
instance. These two characters are generally (but not always) the unique
alphanumeric characters under which the diskette in question was formatted
originally. The diskette name and ID are cosmetic in nature and appear in the
directory for your reference purposes only. The 2A indicates the DOS version
and format, 4040 in this instance — again a holdover. Next we see the active
file entries on the diskette itself. Each directory entry has three fields:

1. The number of blocks/sectors the given file occupies.
2. The file name.
3. The file type.

Your demo diskette came with 15 active files on it. Moreover, they are all
program files denoted by PRG. The last entry in the directory is the
remaining number of available blocks/sectors left on the diskette for
storage. It is the difference between 664 blocks available at the time of
original formatting and the sum of the blocks of the active files (664 - 106
= 558).

What you see on your screen is not necessarily how the directory is stored on
your diskette, however. Let's begin our look at the directory with the Block
Availability Map (BAM).



## 4.3 The Block Availability Map (BAM)

The BAM is where the DOS keeps track of which sectors (blocks) on the
diskette contain information (are in use) and which ones can be used for
storing new information (are free). This map is stored on track 18, sector 0.
Here is a hex dump of that sector on the 1541TEST/DEMO disk so we can examine
it in detail.

                1541TEST/DEMO

             TRACK 18 - SECTOR 0

    . 00: 12 01 41 00 15 FF FF 1F ..A.....  BAM TRACK   1
    . 08: 15 FF FF 1F 15 FF FF 1F ........  BAM TRACKS  2-3
    . 10: 15 FF FF 1F 15 FF FF 1F ........  BAM TRACKS  4-5
    . 18: 15 FF FF 1F 15 FF FF 1F ........  BAM TRACKS  6-7
    . 20: 15 FF FF 1F 15 FF FF 1F ........  BAM TRACKS  8-9
    . 28: 15 FF FF 1F 15 FF FF 1F ........  BAM TRACKS 10-11
    . 30: 15 FF FF 1F 15 FF FF 1F ........  BAM TRACKS 12-13
    . 38: 11 D7 5F 1F 00 00 00 00 .W......  BAM TRACKS 14-15
    . 40: 00 00 00 00 00 00 00 00 ........  BAM TRACKS 16-17
    . 48: 10 EC FF 07 00 00 00 00 ........  BAM TRACKS 18-19
    . 50: 00 00 00 00 12 BF FF 07 .....?..  BAM TRACKS 20-21
    . 58: 13 FF FF 07 13 FF FF 07 ........  BAM TRACKS 22-23
    . 60: 13 FF FF 07 12 FF FF 03 ........  BAM TRACKS 24-25
    . 68: 12 FF FF 03 12 FF FF 03 ........  BAM TRACKS 26-27
    . 70: 12 FF FF 03 12 FF FF 03 ........  BAM TRACKS 28-29
    . 78: 12 FF FF 03 11 FF FF 01 ........  BAM TRACKS 30-31
    . 80: 11 FF FF 01 11 FF FF 01 ........  BAM TRACKS 32-33
    . 88: 11 FF FF 01 11 FF FF 01 ........  BAM TRACKS 34-35
    . 90: 31 35 34 31 54 45 53 54 1541TEST  DISK NAME
    . 98: 2F 44 45 4D 4F A0 A0 A0 /DEMO
    . A0: A0 A0 5A 58 A0 32 41 A0   ZX 2A   DOS TYPE & DISK ID
    . A8: A0 A0 A0 00 00 00 00 00    .....  UNUSED
    . B0: 00 00 00 00 00 00 00 00 ........
    . B8: 00 00 00 00 00 00 00 00 ........
    . C0: 00 00 00 00 00 00 00 00 ........
    . C8: 00 00 00 00 00 00 00 00 ........
    . D0: 00 00 00 00 00 00 00 00 ........
    . D8: 00 00 00 00 00 00 00 00 ........
    . E0: 00 00 00 00 00 00 00 00 ........
    . E8: 00 00 00 00 00 00 00 00 ........
    . F0: 00 00 00 00 00 00 00 00 ........
    . F8: 00 00 00 00 00 00 00 00 ........

As indicated above, the BAM does not take up all 256 bytes on this sector.
There are several other things stored here as well. The table below
identifies the various parts. Note that the sector dump above uses
hexadecimal notation while the table below gives the decimal equivalents.

  Bytes  | Contents  | Purpose
:-------:|:---------:|:-----------------------------------------------
   0/1   |    18/1   | Pointer to first sector of directory entries
    2    |     65    | ASCII character A indicating 1541/4040 format
    3    |     0     | Unused
  4-143  |           | Block Availability Map (BAM)
 144-159 |           | Diskette name padded with shifted spaces
 160-161 |    160    | Shifted spaces
 162-163 |           | Diskette ID
   164   |    160    | Shifted space
 165-166 |   50/65   | DOS version and format type (2A)
 167-170 |    160    | Shifted spaces
 170-255 |     ?     | Unused

In the BAM four bytes are used to describe the status of each track. As a
result, the BAM takes up a total of 4 x 35 = 140 bytes (bytes 4-143 or
$04-$8F). Let's examine the entry for track 14 to see what these four bytes
mean. The entry for track 14 begins at byte 14 x 4 = 56 ($38). It looks like
this:


    . 38: 11 D7 5F 1F 00 00 00 00 .W......  BAM TRACKS 14-15
          ** ** ** **

The first byte for track 14 (location $38 = 56) indicates the number of
blocks free on this track.


    . 38: 11 D7 5F 1F 00 00 00 00 .W......  BAM TRACKS 14-15
          **

In this case there are $11 or 17 (1 * 16 + 1) blocks free.

When the DOS calculates the number of blocks free on a diskette, it sums this
byte from each track's entry in the BAM. Let's do our own blocks free
calculation to see how it is done. All we have to do is sum up the decimal
values of every fourth byte starting with byte 4 like this:

                              HEX    DECIMAL
     ZONE    BYTE    TRACK   VALUE    VALUE
    ------  ------  ------- ------- ---------
      1        4       1      $1F       21
               8       2      $1F       21
              12       3      $1F       21
              16       4      $1F       21
              20       5      $1F       21
              24       6      $1F       21
              28       7      $1F       21
              32       8      $1F       21
              36       9      $1F       21
              40      10      $1F       21
              44      11      $1F       21
              48      12      $1F       21
              52      13      $1F       21
              56      14      $11       17
              60      15      $00        0
              64      16      $00        0
              68      17      $00        0

    2         72      18      $10       16
              76      19      $13       19
              80      20      $13       19
              84      21      $13       19
              88      22      $13       19
              92      23      $13       19
              96      24      $13       19

    3        100      25      $12       18
             104      26      $12       18
             108      27      $12       18
             112      28      $12       18
             116      29      $12       18
             120      30      $12       18

    4        124      31      $11       17
             128      32      $11       17
             132      33      $11       17
             136      34      $11       17
             140      35      $11     + 17
                                    ---------
                                       574      BLOCKS FREE

Wait a minute! We calculated 574 blocks free but the directory shows 558. How
do we explain this discrepancy? Easy. Remember that the DOS reserves track 18
for its own use. Therefore the blocks free on that particular track are not
returned to us (574 - 16 = 558). Sixteen sectors on track 18 are still free,
but available only to the DOS.

Now that you have seen how to calculate the number of blocks free on a
diskette, let's get back to our analysis of track 14. The BAM entry looked
like this:


    . 38: 11 D7 5F 1F 00 00 00 00 .W......  BAM TRACKS 14-15
          ** ** ** **

The first byte was easy to interpret. The remaining three bytes are a bit
trickier (no pun intended). They are a bit map showing the status of the
sectors on a given track. Bit mapping is used to save space. If one byte were
used for each of the 683 sectors, the BAM would take up three sectors (683 /
256). This would be inefficient. By using bit mapping, each byte describes
the status of eight sectors. This way only three bytes are needed for each
track. Let's examine the bit map for track 14 of our 1541 TEST/DEMO.


    . 38: 11 D7 5F 1F 00 00 00 00 .W......  BAM TRACKS 14-15
          ** ** ** **

     LOCATION       $39=57          $3A=58          $3B=59
    BYTE VALUE       $D7             $5F             $1F
      BINARY       11010111        01011111        00011111 *

      SECTOR                       111111             21111
      NUMBER       76543210        54321098        xxx09876

                 * 1 = FREE
                   O = ALLOCATED

Sectors 0 to 7 are represented by the byte at location 57. Sectors 8 through
15 are stored in the byte at location 58. Finally, sectors 16 through 20 are
depicted by the byte at location 59. When decoded, a bit that is high or a 1
indicates that a sector is not currently in use (free) and can be written to.
A bit that is low or a 0 is currently in use (allocated) and will be
overlooked by the DOS when writing subsequently takes place to the diskette.
The third byte is always incomplete since a maximum of 21 sectors are written
to any track. This particular byte is automatically adjusted by the DOS
during initial formatting to indicate the proper number of sectors for this
track. Three bytes are still used irregardless of the zone, however. If you
count up the 1s in the bit map for track 14, you will find that there are 17
free sectors on track 14. This agrees with the blocks free count for the
track stored at byte location $38 (56) in the BAM, i.e., $11 or 17 decimal.

To ensure that you understand how the bit mapping works, let's take a look at
track 18. Since track 18 is used for storing the directory we would expect
some allocation of sectors here. Byte 72 shows $10 or 16 sectors available
here. They are bit mapped in bytes 73, 74, and 75 as follows:


    . 48: 10 EC FF 07 00 00 00 00 ........  BAM TRACKS 18-19
          ** ** ** **

     LOCATION       $49=73          $4A=74          $4B=75
    BYTE VALUE       $EC             $FF             $07
      BINARY       11101100        11111111        00000111 *

      SECTOR                       111111             21111
      NUMBER       76543210        54321098        xxx09876

                 * 1 = FREE
                   O = ALLOCATED

If you are still unsure of yourself, don't be too concerned. The DOS looks
after the BAM. Let's move on and explore the actual directory entries
themselves. Sectors 1 through 18 on track 18 are reserved specifically for
them.



## 4.4 The Directory Entries

Recall that bytes 0 and 1 of track 18, sector 0 point to the next track and
sector of the directory. In this particular instance, the BAM points to track
18, sector 1. Let's examine this sector in detail.

                1541TEST/DEMO

             TRACK 18 - SECTOR 01

    . 00: 12 04 82 11 00 48 4F 57 .....HOW  FILE ENTRY #1
    . 08: 20 54 4F 20 55 53 45 A0  TO USE
    . 10: A0 A0 A0 A0 A0 00 00 00      ...
    . 18: 00 00 00 00 00 00 0D 00 ........
    . 20: 00 00 82 11 03 48 4F 57 .....HOW  FILE ENTRY #2
    . 28: 20 50 41 52 54 20 54 57  PART TW
    . 30: 4F A0 A0 A0 A0 00 00 00 O    ...
    . 38: 00 00 00 00 00 00 05 00 ........
    . 40: 00 00 82 11 09 56 49 43 .....VIC  FILE ENTRY #3
    . 48: 2D 32 30 20 57 45 44 47 -20 WEDG
    . 50: 45 A0 A0 A0 A0 00 00 00 E    ...
    . 58: 00 00 00 00 00 00 04 00 ........
    . 60: 00 00 82 13 00 46 2D 36 .....C-6  FILE ENTRY #4
    . 68: 34 20 57 45 44 47 45 A0 4 WEDGE
    . 70: A0 A0 A0 A0 A0 00 00 00      ...
    . 78: 00 00 00 00 00 00 01 00 ........
    . 80: 00 00 82 13 01 44 4F 53 .....DOS  FILE ENTRY #5
    . 88: 20 35 2E 31 A0 A0 A0 A0  5.1
    . 90: A0 A0 A0 A0 A0 00 00 00      ...
    . 98: 00 00 00 00 00 00 04 00 ........
    . A0: 00 00 82 13 03 43 4F 50 .....COP  FILE ENTRY #6
    . A8: 59 2F 41 4C 4C A0 A0 A0 Y/ALL
    . B0: A0 A0 A0 A0 A0 00 00 00      ...
    . B8: 00 00 00 00 00 00 0B 00 ........
    . C0: 00 00 82 13 09 50 52 49 .....PRI  FILE ENTRY #7
    . C8: 4E 54 45 52 20 54 45 53 NTER TES
    . D0: 54 A0 A0 A0 A0 00 00 00 T    ...
    . D8: 00 00 00 00 00 00 09 00 ........
    . E0: 00 00 82 10 00 44 49 53 .....DIS  FILE ENTRY #8
    . E8: 4B 20 41 44 44 52 20 43 K ADDR C
    . F0: 48 41 4E 47 45 00 00 00 HANGE...
    . F8: 00 00 00 00 00 00 04 00 ........


The contents of any directory sector can be tabled as follows:

Byte    | Contents | Purpose
:------:|:--------:|:-------------------------------------
     0  |          | Track of the next directory block
     1  |          | Sector of the next directory block
        |          |
  2-31  |          | File entry #1 in the directory block
        |          |
 32-33  |    0     | Unused
 34-63  |          | File entry #2 in the directory block
        |          |
 64-65  |    0     | Unused
 66-95  |          | File entry #3 in the directory block
        |          |
 96-97  |    0     | Unused
 98-127 |          | File entry #4 in the directory block
128-129 |    0     | Unused
130-159 |          | File entry #5 in the directory block
        |          |
160-161 |    0     | Unused
162-191 |          | File entry #6 in the directory block
        |          |
192-193 |    0     | Unused
194-223 |          | File entry #7 in the directory block
        |          |
224-225 |    0     | Unused
226-255 |          | File entry #8 in the directory block

Eight file entries are recorded per sector. Let's examine the contents of a
single directory file entry.

    . 00: 12 04 82 11 00 48 4F 57 .....HOW
          ** **
    . 08: 20 54 4F 20 55 53 45 A0  TO USE
    . 10: A0 A0 A0 A0 A0 00 00 00      ...
    . 18: 00 00 00 00 00 00 0D 00 ........

Because this is the first entry in the directory, bytes 0 and 1 are
significant. They point to track 18, sector 4 (converts to 18). This
indicates that there are further directory entries. You will note that the
sectors are not sequential in nature, i.e., sector 1 does not point to sector
2, etc. Remember that the diskette itself is rotating at 300 rpm. Staggering
the use of the sectors allows quicker access and fewer rotations of the drive
mechanism and the media. Typically sectors are staggered in increments of 10.
The directory track is staggered in increments of 3, however. The table below
indicates the sequence in which a full directory containing 144 files is
stored:

        SECTOR FILLING SEQUENCE
           FOR THE DIRECTORY

             0 (BAM)
             1, 4, 7, 10, 13, 16
             2, 5, 8, 11, 14, 17
             3, 6, 9, 12, 15, 18


When a diskette is initially formatted, sector 1 is set up with 8 null
entries. As you store files on the diskette the directory grows. It soon
becomes a long chain of directory sectors. The first two bytes in a sector
point to the next directory sector in the chain (this is known as a forward
pointer). But, what about the last sector in the chain? It has nothing to
point to! In the last sector in the chain, there is no forward pointer; byte
0 contains a 0 ($00) and byte 1 contains a 255 ($FF) as indicated below. This
indicates to the DOS that there are no more sectors in the directory.

    . 00: 00 FF xx xx xx xx xx xx ........

One final note about chaining. Commodore uses only forward pointers. A sector
does not show where it came from, only where it is going. This makes recovery
of corrupted files much more difficult, but more about that later.

Back to our example:

    . 00: 12 04 82 11 00 48 4F 57 .....HOW
                **
    . 08: 20 54 4F 20 55 53 45 A0  TO USE
    . 10: A0 A0 A0 A0 A0 00 00 00      ...
    . 18: 00 00 00 00 00 00 0D 00 ........

The first byte in the file entry is the file-type byte. In this instance we
see an $82. This is interpreted by the DOS to mean that the file entry is a
program. The following table outlines Commodores file types.

HEX   |  ASCII  | FILE TYPE                | DIRECTORY SHOWS
:----:| -------:|:------------------------ |:----------------
      |         |                          |
$00   |    0    | Scratched                | Does not appear
      |         |                          |
$80   |  128    | Deleted                  | DEL
$81   |  129    | Sequential               | SEQ
$82   |  130    | Program                  | PRG
$83   |  131    | User                     | USR
$84   |  132    | Relative                 | REL
      |         |                          |
$00   |    0    | Unclosed deleted         | Same as scratched
$01   |    1    | Unclosed sequential      | *SEQ
$02   |    2    | Unclosed program         | *PRG
$03   |    3    | Unclosed user            | *USR
$04   |    4    | Unclosed relative        | Cannot occur
      |         |                          |
$A0   |  160    | Deleted @ replacement    | DEL
$A1   |  161    | Sequential @ replacement | SEQ
$A2   |  162    | Program @ replacement    | PRG
$A3   |  163    | User @ replacement       | USR
$A4   |  164    | Relative @ replacement   | Cannot occur
      |         |                          |
$C0   |  192    | Locked deleted           | DEL<
$C1   |  193    | Locked sequential        | SEQ<
$C2   |  194    | Locked program           | PRG<
$C3   |  195    | Locked user              | USR<
$C4   |  196    | Locked relative          | REL<

Note: It is possible to edit the file-type byte and get very unusual file
types appearing in the directory (SR?< is one possibility). However, these
file types have no practical use.

Enough esoterica for now. Let's get back to our example:

The next two bytes in the file entry are a pointer to where the first sector
of that particular file is stored on the diskette.

    . 00: 12 04 82 11 00 48 4F 57 .....HOW
                   ** **
    . 08: 20 54 4F 20 55 53 45 A0  TO USE
    . 10: A0 A0 A0 A0 A0 00 00 00      ...
    . 18: 00 00 00 00 00 00 0D 00 ........

This file starts on track 17 ($11), sector 0 ($00).

Next we have the file name.

    . 00: 12 04 82 11 00 48 4F 57 .....HOW
                         ** ** **
    . 08: 20 54 4F 20 55 53 45 A0  TO USE
          ** ** ** ** ** ** ** **
    . 10: A0 A0 A0 A0 A0 00 00 00      ...
          ** ** ** ** **
    . 18: 00 00 00 00 00 00 0D 00 ........

In this case our file is named "HOW TO USE". Note that file names are padded
out to 16 characters with shifted spaces ($A0) just like the diskette name.
The shifted spaces do not show as part of the file name, however, when the
directory is displayed.

    . 00: 12 04 82 11 00 48 4F 57 .....HOW
    . 08: 20 54 4F 20 55 53 45 A0  TO USE
    . 10: A0 A0 A0 A0 A0 00 00 00      ...
                         ** ** **
    . 18: 00 00 00 00 00 00 0D 00 ........

The next three bytes are unused except for relative file entries. For a
relative file bytes $15 (21) and $16 (22) point to the first set of side
sectors. Byte $17 (23) gives the record size with which the relative file was
created. This special file type will be examined in detail later.

The next four bytes are always unused and therefore null ($00).

    . 00: 12 04 82 11 00 48 4F 57 .....HOW
    . 08: 20 54 4F 20 55 53 45 A0  TO USE
    . 10: A0 A0 A0 A0 A0 00 00 00      ...
    . 18: 00 00 00 00 00 00 0D 00 ........
          ** ** ** **

The following two bytes are reserved for use by the DOS during the save and
replace operation (@ replacement). Their function can only be viewed by
interrupting the drive during a SAVE "@0:file name",8 routine. This is not
recommended for obvious reasons. (During an @ replacement the file-type byte
is ORed with $20 first. A new copy of the file is then written to the disk.
Bytes 28 ($1C) and 29 ($1D) contain the track and sector pointer to the start
of the new replacement file. At the end of the @ operation the sectors that
held the old file are marked as free in the BAM. The new track and sector
pointer is then moved from bytes 28 and 29 to bytes 3 ($03) and 4 ($04)
respectively and bytes 28 and 29 are zeroed again. The proper file type is
then restored at byte 2. See Chapter 9 about the bug in the @ replacement
command.)

    . 00: 12 04 82 11 00 48 4F 57 .....HOW
    . 08: 20 54 4F 20 55 53 45 A0  TO USE
    . 10: A0 A0 A0 A0 A0 00 00 00      ...
    . 18: 00 00 00 00 00 00 0D 00 ........
                      ** **

The final two bytes in a file entry are the number of blocks it occupies on
the diskette. It is the sum of the leftmost byte (lo-byte) + the rightmost
byte (hi-byte) * 256.

    . 00: 12 04 82 11 00 48 4F 57 .....HOW
    . 08: 20 54 4F 20 55 53 45 A0  TO USE
    . 10: A0 A0 A0 A0 A0 00 00 00      ...
    . 18: 00 00 00 00 00 00 0D 00 ........
                            ** **
                            LO HI

In our example, the file is (13 + 0 * 256) = 13 blocks long.

To be sure you understand the file entries work let's break out the first
sector of the test/demo directory to show each file entry. Remember that
bytes 0 and 1 of each entry are unused with the exception of the first entry.
Here they represent a forward track and sector chain and have nothing to do
with that file in particular.


                1541TEST/DEMO

             TRACK 18 - SECTOR 01

              DIRECTORY ENTRY 1

    . 00: 12 04 82 11 00 48 4F 57 .....HOW  File type = $82 = PRG
    . 08: 20 54 4F 20 55 53 45 A0  TO USE   Starts on 17/1 ($11/$00)
    . 10: A0 A0 A0 A0 A0 00 00 00      ...  Name: HOW TO USE
    . 18: 00 00 00 00 00 00 0D 00 ........  File length: 13 BLOCKS

              DIRECTORY ENTRY 2

    . 20: 00 00 82 11 03 48 4F 57 .....HOW  File type = $82 = PRG
    . 28: 20 50 41 52 54 20 54 57  PART TW  Starts on 17/3 ($11/$03)
    . 30: 4F A0 A0 A0 A0 00 00 00 O    ...  Name: HOW PART TWO
    . 38: 00 00 00 00 00 00 05 00 ........  File length: 5 BLOCKS

              DIRECTORY ENTRY 3

    . 40: 00 00 82 11 09 56 49 43 .....VIC  File type = $82 = PRG
    . 48: 2D 32 30 20 57 45 44 47 -20 WEDG  Starts on 17/9 ($11/09)
    . 50: 45 A0 A0 A0 A0 00 00 00 E    ...  Name: VIC-20 WEDGE
    . 58: 00 00 00 00 00 00 04 00 ........  File length: 4 BLOCKS

              DIRECTORY ENTRY 4

    . 60: 00 00 82 13 00 46 2D 36 .....C-6  File type = $82 = PRG
    . 68: 34 20 57 45 44 47 45 A0 4 WEDGE   Starts on 19/0 ($13/$00)
    . 70: A0 A0 A0 A0 A0 00 00 00      ...  Name C-64 WEDGE
    . 78: 00 00 00 00 00 00 01 00 ........  File length: 1 BLOCK

              DIRECTORY ENTRY 5

    . 80: 00 00 82 13 01 44 4F 53 .....DOS  File type = $82 = PRG
    . 88: 20 35 2E 31 A0 A0 A0 A0  5.1      Starts on 19/1 ($13/$01)
    . 90: A0 A0 A0 A0 A0 00 00 00      ...  Name: DOS 5.1
    . 98: 00 00 00 00 00 00 04 00 ........  File length: 4 BLOCKS

              DIRECTORY ENTRY 6

    . A0: 00 00 82 13 03 43 4F 50 .....COP  File type = $82 = PRG
    . A8: 59 2F 41 4C 4C A0 A0 A0 Y/ALL     Starts on 19/3 ($13/03)
    . B0: A0 A0 A0 A0 A0 00 00 00      ...  Name: COPY/ALL
    . B8: 00 00 00 00 00 00 0B 00 ........  File length: 11 BLOCKS

              DIRECTORY ENTRY 7

    . C0: 00 00 82 13 09 50 52 49 .....PRI  File type = $82 = PRG
    . C8: 4E 54 45 52 20 54 45 53 NTER TES  Starts on 19/9 ($13/09)
    . D0: 54 A0 A0 A0 A0 00 00 00 T    ...  Name: PRINTER TEST
    . D8: 00 00 00 00 00 00 09 00 ........  File length: 9 BLOCKS

              DIRECTORY ENTRY 8

    . E0: 00 00 82 10 00 44 49 53 .....DIS  File type = $82 = PRG
    . E8: 4B 20 41 44 44 52 20 43 K ADDR C  Starts on 16/0 ($10/00)
    . F0: 48 41 4E 47 45 00 00 00 HANGE...  Name:DISK ADDR CHANGE
    . F8: 00 00 00 00 00 00 04 00 ........  File length: 4 BLOCKS


We will end our tour of the directory by displaying the next sector (track
18, sector 4) which happens to end the directory chain ($00, $FF in bytes 0
and 1, respectively). Notice that only seven directory entries are present in
this block. The last directory entry is a null entry. It will be converted
into a valid entry when the directory is expanded.


                1541TEST/DEMO

             TRACK 18 - SECTOR 04

    . 00: 00 FF 82 10 01 44 49 52 .....DIR  File type = $82 = PRG
    . 08: A0 A0 A0 A0 A0 A0 A0 A0           Starts on 16/1 ($10/01)
    . 10: A0 A0 A0 A0 A0 00 00 00      ...  Name: DIR
    . 18: 00 00 00 00 00 00 04 00 ........  File length: 4 BLOCKS

    . 20: 00 00 82 10 03 56 49 45 .....VIE  File type = $82 = PRG
    . 28: 57 20 42 41 4D A0 A0 A0 W BAM     Starts on 16/3 ($10/03)
    . 30: A0 A0 A0 A0 A0 00 00 00      ...  Name:VIEW BAM
    . 38: 00 00 00 00 00 00 06 00 ........  File length: 6 BLOCKS

    . 40: 00 00 82 10 07 43 48 45 .....CHE  File type = $82 = PRG
    . 48: 43 4B 20 44 49 53 4B A0 CK DISK   Starts on 16/7 ($10/07)
    . 50: A0 A0 A0 A0 A0 00 00 00      ...  Name: CHECK DISK
    . 58: 00 00 00 00 00 00 04 00 ........  File length: 4 BLOCKS

    . 60: 00 00 82 10 0F 44 49 53 .....DIS  File type = $82 = PRG
    . 68: 50 4C 41 59 20 54 26 53 PLAY T&S  Starts on 16/15 ($10/$0F)
    . 70: A0 A0 A0 A0 A0 00 00 00      ...  Name: DISPLAY T&S
    . 78: 00 00 00 00 00 00 0E 00 ........  File length: 14 BLOCKS

    . 80: 00 00 82 14 02 50 45 52 .....PER  File type = $82 = PRG
    . 88: 46 4F 52 4D 41 4E 43 45 FORMANCE  Starts on 20/2 ($14/$02)
    . 90: 20 54 45 53 54 00 00 00  TEST...  Name: PERFORMANCE TEST
    . 98: 00 00 00 00 00 00 09 00 ........  File length: 9 BLOCKS

    . A0: 00 00 82 14 07 50 45 52 .....SEQ  File type = $82 = PRG
    . A8: 55 45 4E 54 49 41 4C 20 UENTIAL   Starts on 20/7 ($14/$07)
    . B0: 46 49 4C 45 A0 00 00 00 FILE ...  Name: SEQUENTIAL FILE
    . B8: 00 00 00 00 00 00 05 00 ........  File length: 5 BLOCKS

    . C0: 00 00 82 0F 01 52 41 4E .....RAN  File type = $82 = PRG
    . C8: 44 4F 4D 20 46 49 4C 45 DOM FILE  Starts on 15/1 ($0F/$01)
    . D0: A0 A0 A0 A0 A0 00 00 00      ...  Name: RANDOM FILE
    . D8: 00 00 00 00 00 00 0D 00 ........  File length: 13 BLOCKS

    . EO: 00 00 00 00 00 00 00 00 ........  NULL ENTRY
    . E8: 00 00 00 00 00 00 00 00 ........
    . F0: 00 00 00 00 00 00 00 00 ........
    . F8: 00 00 00 00 00 00 00 00 ........


You will find four of the utilities listed in Appendix C particularly helpful
in furthering your understanding of the organization of a diskette. The first
program is DISPLAY TRACK & SECTOR. The hex dumps in this section were
generated using this utility. A hex dump can be sent either to the screen or
printer. When sent to the screen only half a page of the specified track and
sector is displayed at one time to prevent scrolling. Bytes 0 - 127 ($00 -
$7F) are displayed first followed by bytes 128 - 255 ($80 - $FF). Use this
program for your own experimentation. The second program is DISPLAY A BLOCK
AVAILABILITY MAP. It portrays the BAM in a two-dimensional representation.
The diskette name, ID, DOS version, and blocks free are also displayed. The
third program is VIRTUAL DIRECTORY. It displays a directory in its entirety
including scratched files. Output can be directed to a printer by changing
the OPEN 4,3 statement in line 440 to OPEN 4,4. The last program, DISPLAY A
CHAIN, traces a file chain. The chain of sectors may be viewed on the screen
or sent to the printer.

The programming techniques that are used in these sample programs will be
partially explained in later sections.

Now that we've seen how the directory is kept, let's look at how the
different types of files are actually stored on a diskette. We'll start by
looking at a program file.



## 4.5 Program File Storage

The most common type of file is a program file, PRG. It is designated by an
$82 in the directory. Program file structure is quite simple.
Diagrammatically, the first sector (block) in a program file looks like this.

    +-------+--------+------+------+---------------------------------+
    | TRACK | SECTOR | LOAD | LOAD |       THE FIRST 252 BYTES       |
    | LINK  | LINK   |  LO  |  HI  |         OF YOUR PROGRAM         |
    +-------+--------+------+------+---------------------------------+


  Byte  | Purpose
:------:|:-------------------------------------------------------------------
        |
   0    | Track of the next block in this file
   1    | Sector of the next block in this file
   2    | Lo-byte of the load address
   3    | Hi-byte of the load address
        |
 4-255  | The first 252 bytes of the program


The first pair of bytes are the pointer to the track and sector of the next
block in the file. Technically, this is known as a "forward pointer." It
points ahead to the next sector in the file. All Commodore files use this
type of pointer.

The second pair of bytes is the "load address" of the file in lo-byte/hi-byte
form. They indicate where the program is to be loaded into memory. A BASIC
program that was saved from a C64 will have a $01 and a $08 in these two
locations. This indicates that the program is to be loaded into memory
starting at memory location $0801 (remember it is in lo-byte/hi-byte form).
In decimal notation this is memory location 2049 — the start of BASIC on a
C64.

Have you ever wondered about the significance of the ",1" in the command LOAD
"name",8,1? It determines whether or not a program is "relocated" when it is
loaded into memory. If you do not specify the ",1", the C64 will ignore the
load address at the start of the file and load the program starting at memory
location $0801 (2049). When the ",1" is present, the C64 (or VIC-20) will pay
attention to the load address and load the program into memory starting at
the location specified by bytes $02 and $03.

The remaining sectors, except the last one, look like this:

    +-------+--------+------------------------------------+
    | TRACK | SECTOR |         THE NEXT 254 BYTES         |
    | LINK  | LINK   |          OF YOUR PROGRAM           |
    +-------+--------+------------------------------------+


  Byte | Purpose
:-----:|:--------------------------------------------------------------------
       |
   0   | Track of the next block in this file
   1   | Sector of the next block in this file
       |
 2-255 | The next 254 bytes of the program


The last block in a program file is special because:

1. It is the last sector.
2. It is usually only partially full.

To signal the DOS that this is the last block, the first byte is set to $00.
The first byte is normally the track link. Since there is no track 0, the DOS
knows that this is the last sector in the file. The second byte indicates the
position of the last byte that is part of the program file. Any bytes beyond
this position are garbage.

Diagrammatically, the last sector in a program file looks like this:

    +------+------+-----------------------------+---------+
    | NULL | LAST |       THE FINAL BYTES       | GARBAGE |
    | $00  | BYTE |       OF YOUR PROGRAM       |         |
    +------+------+-----------------------------+---------+


   Byte   | Purpose
:--------:|:-----------------------------------------------------------------
          |
    0     | Null byte to indicate that this is the last sector
    1     | Number of bytes to read from this sector (N)
          |
   2-N    | The last (N-2) bytes of the program
(N+1)-255 | Garbage


Let's examine the program file "DIR" on your 1541TEST/DEMO disk. DIR appears
in the directory on track 18, sector 04. The directory entry looks like this:

             TRACK 18 - SECTOR 04

    . 00: 00 FF 82 10 01 44 49 52 .....DIR
    . 08: A0 A0 A0 A0 A0 A0 A0 A0
    . 10: A0 A0 A0 A0 A0 00 00 00      ...
    . 18: 00 00 00 00 00 00 04 00 ........

From the entry we see that "DIR" starts at track 16 ($10), sector 01 ($01)
and that the file is four blocks long (4 + 0 * 256).

    . 00: 00 FF 82 10 01 44 49 52 .....DIR
                   ** **
    . 08: A0 A0 A0 A0 A0 A0 A0 A0
    . 10: A0 A0 A0 A0 A0 00 00 00      ...
    . 18: 00 00 00 00 00 00 04 00 ........
                            ** **

Let's look at the first block in this file.

             TRACK 16 - SECTOR 01

    . 00: 10 0B 01 04 0D 04 04 00 ........
    . 08: 9F 32 2C 38 2C 31 35 00 .2,8,15.
    . 10: 1E 04 05 00 99 22 93 22 ....."."
    . 18: 3A 89 20 31 30 30 30 30 :. 10000
    . 20: 00 2E 04 0A 00 9F 31 2C ......1,
    . 28: 38 2C 30 2C 22 24 30 22 8,0,"$0"
    . 30: 00 3C 04 14 00 A1 23 31 .<....#1
    . 38: 2C 41 24 2C 42 24 00 4A ,A$,B$.J
    . 40: 04 1E 00 A1 23 31 2C 41 ....#1,A
    . 48: 24 2C 42 24 00 58 04 28 $,B$.X.(
    . 50: 00 A1 23 31 2C 41 24 2C ..#1,A$,
    . 58: 42 24 00 60 04 32 00 43 B$...2.C
    . 60: B2 30 00 77 04 3C 00 8B .0...<..
    . 68: 20 41 24 B3 B1 22 22 20  A$..""
    . 70: A7 20 43 B2 C6 28 41 24 . C..(A$
    . 78: 29 00 94 04 46 00 8B 20 )...F..
    . 80: 42 24 B3 B1 22 22 20 A7 B$.."" .
    . 88: 20 43 B2 43 AA C6 28 42  C.C..(B
    . 90: 24 29 AC 32 35 36 00 AF $).256..
    . 98: 04 50 00 99 22 12 22 CA .P..".".
    . A0: 28 C4 28 43 29 2C 32 29 (.(C),2)
    . A8: 3B A3 33 29 3B 22 92 22 ;.3);"."
    . B0: 3B 00 C9 04 5A 00 A1 23 ;...Z..#
    . B8: 31 2C 42 24 3A 8B 20 53 1,B$:. S
    . C0: 54 B3 B1 30 20 A7 20 31 T..0 . 1
    . C8: 30 30 30 00 DE 04 64 00 000.....
    . D0: 8B 20 42 24 B3 B1 C7 28 . B$...(
    . D8: 33 34 29 20 A7 20 39 30 34) . 90
    . E0: 00 00 05 6E 00 A1 23 31 ......#1
    . E8: 2C 42 24 3A 8B 20 42 24 ,B$:. B$
    . F0: B3 B1 C7 28 33 34 29 A7 ...(34).
    . F8: 20 99 42 24 3B 3A 89 31  .B$;:.1

Not very recognizable is it? Remember this is C64 internal BASIC not a BASIC
listing. Bytes 0 and 1 are of interest. They are the track and sector link
that point to the next block in the program file. In this case, they point to
track 16 ($10), sector 11 ($0B). Since this is the first data block of the
file, bytes 2 and 3 are also important. They are the load address. We can see
that the load address is $0401 or 1025 decimal. This file was written on a
PET. (The start of BASIC memory on the C64 is at $0801. The VIC-20 begins at
$1001, $1201, or $0401 depending on the amount of external memory.) DIR will
require a straight relocating load, i.e., LOAD "DIR",8. If you used a LOAD
"DIR", 8,1 command, the program would be loaded into the screen RAM of the
C64. NOTE: If you load this program properly, you will NOT be able to get it
to VERIFY correctly. The reason is that the internal BASIC links were changed
when the program was relocated.


    . 00: 10 0B 01 04 0D 04 04 00 ........
          ** ** ** **

Let's follow the forward chain to track 16, sector 11 and take a look at the
start of the second block in our file.


             TRACK 16 - SECTOR 11

    . 00: 10 02 31 30 00 1C 05 78 ..10....
    . 08: 00 A1 23 31 2C 42 24 3A ..#1,B$:
    . 10: 8B 20 42 24 B2 C7 28 33 . B$..(3

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Nothing much of interest here. Let's chain to track 16 ($10), sector 02 ($02)
and take a look at the start of the next block.


             TRACK 16 - SECTOR 02

    . 00: 10 0C B2 22 22 3A 99 22 ..."":."
    . 08: 3E 22 3B 00 1A 06 AB 0F >";.....
    . 10: A1 42 24 3A 8B 42 24 B2 .B$:.B$.

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Again, nothing much of interest. Chain to track 16 ($10), sector 12 ($0C).


             TRACK 16 - SECTOR 12

    . 00: 00 68 8B 20 41 24 B2 22 ... A$."
    . 08: 44 22 20 A7 20 31 30 00 D" . 10.
    . 10: 2D 07 3C 28 8B 20 41 24 -.<(. A$
    . 18: B2 22 2E 22 20 B0 20 41 ."." . A
    . 20: 24 B2 22 3E 22 20 B0 20 *.">" .
    . 28: 41 24 B2 22 3E 22 20 A7 A$.">" .
    . 30: 20 34 30 30 30 00 3E 07  4000.>.
    . 38: 46 28 8B 20 41 24 B2 22 F(. A$."
    . 40: 51 22 20 A7 20 80 00 52 Q" . ..R
    . 48: 07 50 28 8B 20 41 24 B2 .P(. A$.
    . 50: 22 53 22 20 A7 20 35 30 "S" . 50
    . 58: 30 30 00 5E 07 F7 2A 89 00. ..*.
    . 60: 20 31 30 31 30 30 00 00  10100..
    . 68: 00 A0 00 A1 20 54 24 3A .... T$:
    . 70: 8B 20 54 24 B3 B1 22 22 . T$..""
    . 78: 20 A7 20 8D 20 32 30 30  . . 200

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now we're cooking. This is the last sector of the file. How can we tell? The
track of the next block in the file is 0 ($00). But what about the sector
link? It's a misnomer. The sector link in the last block is actually a byte
count. It informs the DOS that only bytes 2 through 104 ($68) are important
in this example. Recall that an end of file in BASIC is designated by three
zeros in a row. An End-or-Identify (EOI) signal will be sent once byte 104
has been transferred across the serial bus. When the C64 receives this EOI
signal, the status variable, ST, will be set to a value of 64. (Any further
attempt to read a byte will cause the drive to time out.) Here's the tail end
of our program. The three null bytes, ($00), at $66/7/8 are the last three
bytes in our program file.

    . 00: 00 68 8B 20 41 24 B2 22 ... A$."
    . 08: 44 22 20 A7 20 31 30 00 D" . 10.
    . 10: 2D 07 3C 28 8B 20 41 24 -.<(. A$
    . 18: B2 22 2E 22 20 B0 20 41 ."." . A
    . 20: 24 B2 22 3E 22 20 B0 20 *.">" .
    . 28: 41 24 B2 22 3E 22 20 A7 A$.">" .
    . 30: 20 34 30 30 30 00 3E 07  4000.>.
    . 38: 46 28 8B 20 41 24 B2 22 F(. A$."
    . 40: 51 22 20 A7 20 80 00 52 Q" . ..R
    . 48: 07 50 28 8B 20 41 24 B2 .P(. A$.
    . 50: 22 53 22 20 A7 20 35 30 "S" . 50
    . 58: 30 30 00 5E 07 F7 2A 89 00. ..*.
    . 60: 20 31 30 31 30 30 00 00  10100..
    . 68: xx xx xx xx xx xx xx xx .

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

What about the rest of the block? Ignore it. It is garbage. The DOS does not
zero out a buffer before it begins filling it with new information sent from
the computer. As a result, the last block in a file, which is almost never
filled with new information, is padded with whatever happened to be left in
the buffer from a previous read or write operation. There are two exceptions
to the rule, namely, the directory and relative files. A partial directory
block is always padded with nulls ($00). Moreover, it always appears as a
full block. Bytes 0 and 1 of the last directory block will contain a $00 and
a $FF, respectively. Relative file structure will be explained shortly.



## 4.6 Sequential File Storage

The format of a sequential file is very straightforward. All the sectors,
except the last one, look like this:

    +-------+--------+-------------------+
    | TRACK | SECTOR | 254 BYTES OF DATA |
    | LINK  | LINK   |                   |
    +-------+--------+-------------------+


Byte     | Purpose
:------- |:------------------------------------------------------------------
         |
0        | Track of the next block in this file
1        | Sector of the next block in this file
         |
2-255    | 254 bytes of data


The last block in a sequential file is special for two reasons:

1. It is the last sector.
2. It is usually only partially full.

To signal the DOS that this is the last block, the first byte is set to $00.
The first byte is normally the track link. Since there is no track 0, the DOS
knows that this is the last sector in the file. The second byte indicates the
position of the last byte in the file. Any bytes beyond this position are
garbage.

Diagrammatically, the last sector in the file looks like this:

    +------+------+---------------------------------+---------+
    | NULL | LAST |     THE FINAL DATA BYTES IN     | GARBAGE |
    | $00  | BYTE |       YOUR SEQUENTIAL FILE      |         |
    +------+------+---------------------------------+---------+


Byte      | Purpose
:-------- |:-----------------------------------------------------------------
          |
0         | Null byte to indicate this is the last sector
1         | Position of the last byte in the file (N)
          |
2-N       | The last N-2 bytes of the sequential file
(N+1)-255 | Garbage


No sequential files appear on the 1541TEST/DEMO. (The file named SEQUENTIAL
FILE is a program file demonstrating the sequential access method.) The C-64
DISK BONUS PACK does come with one sequential file on it. The file named `"
  DIRECTORY   "` appears as a SEQ when displaying the directory.
`"   DIRECTORY   "` can be found at track 18, sector 01 on the C-64 DISK
BONUS PACK. Let's take a peek at the directory entry for this file:

             TRACK 18 - SECTOR 01

    . 20: 00 00 81 11 01 20 20 20 .....
    . 28: 44 49 52 45 43 54 4F 52 DIRECTOR
    . 30: 59 20 20 20 A0 00 00 00 Y    ...
    . 38: 00 00 00 00 00 00 02 00 ........

`"   DIRECTORY   "` is the second file entry in the directory.

    . 20: 00 00 81 11 01 20 20 20 .....
                ** ** **
    . 28: 44 49 52 45 43 54 4F 52 DIRECTOR
    . 30: 59 20 20 20 A0 00 00 00 Y    ...
    . 38: 00 00 00 00 00 00 02 00 ........
                            **

A sequential file is designated by an $81 in the directory. The first block
of this file is stored on track 17 ($11), sector 1 ($01). We also see that
`"   DIRECTORY   "` is two blocks long (2 + 0 * 256). Let's take a look at
the first half of the starting data block.

             TRACK 17 - SECTOR 01

    . 00: 11 OB 43 36 34 20 53 54 ..C64 ST
    . 08: 41 52 54 45 52 20 4B 49 ARTER KI
    . 10: 54 20 20 20 36 34 20 20 T   64
    . 18: 32 41 OD 31 35 34 31 20 2A.1541
    . 20: 42 41 43 4B 55 50 0D 41 BACKUP.A
    . 28: 4D 4F 52 54 20 54 41 42 MORT TAB
    . 30: 4C 45 0D 41 52 52 4F 57 LE.ARROW
    . 38: 0D 42 49 54 53 20 41 4E .BITS AN
    . 40: 44 20 42 59 54 45 53 0D D BYTES.
    . 48: 43 41 4C 45 4E 44 41 52 CALENDAR
    . 50: 0D 43 48 41 4E 47 45 20 .CHANGE
    . 58: 44 49 53 4B 0D 43 48 41 DISK.CHA
    . 60: 52 20 42 4F 4F 54 0D 43 R BOOT.C
    . 68: 4F 4C 4F 52 20 54 45 53 OLOR TES
    . 70: 54 0D 43 4F 50 59 2D 41 T.COPY-A
    . 78: 4C 4C 36 34 0D 44 45 4D LL64.DEM

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Bytes 0 and 1 are the track and sector link (forward pointer). They inform us
that the next data block can be found at track 17, sector 11. The remaining
254 bytes are data. The sequential data that appear here are in fact the disk
name (C64 STARTER KIT), the cosmetic disk ID (64), and the file names found
on the C-64 DISK BONUS PACK. It is interesting to note that a carriage return
character ($0D) was used as a delimiter to separate record entries. Next we
see:

             TRACK 17 - SECTOR 11

    . 00: 00 86 2D 20 59 41 4E 4B ..- YANK
    . 08: 45 45 0D 53 4F 55 4E 44 EE.SOUND
    . 10: 20 2D 20 41 4C 49 45 4E  - ALIEN
    . 18: 0D 53 4F 55 4E 44 20 2D .SOUND -
    . 20: 20 42 4F 4D 42 0D 53 4F  BOMB.SO
    . 28: 55 4E 44 20 2D 20 43 4C UND - CL
    . 30: 41 50 0D 53 4F 55 4E 44 AP.SOUND
    . 38: 20 2D 20 47 55 4E 46 49  - GUNFI
    . 40: 52 45 0D 53 4F 55 4E 44 RE.SOUND
    . 48: 20 2D 20 50 4F 4E 47 0D  - PONG.
    . 50: 53 4F 55 4E 44 20 2D 20 SOUND -
    . 58: 52 41 59 47 55 4E 0D 53 RAYGUN.S
    . 60: 4F 55 4E 44 20 2D 20 53 OUND - S
    . 68: 49 52 45 4E 0D 53 50 52 IREN.SPR
    . 70: 49 54 45 20 42 4F 4F 54 ITE BOOT
    . 78: 0D 53 55 50 45 52 4D 4F .SUPERMO
    . 80: 4E 36 34 2E 56 31 0D 59 N64.V1.Y
    . 88: 54 53 50 52 49 54 45 53 TSPRITES
    . 90: A0 A0 A0 A0 A0 00 00 00 ........
    . 98: 00 00 00 00 00 00 05 00 ........
    . A0: 00 00 82 07 00 53 4E 4F .....SNO
    . A8: 4F 50 59 20 4D 41 54 48 OPY MATH
    . B0: A0 A0 A0 A0 A0 00 00 00 ........
    . B8: 00 00 00 00 00 00 33 00 ......3.
    . C0: 00 00 82 1D 00 41 4D 4F .....AMO
    . C8: 52 54 20 54 41 42 4C 45 RT TABLE
    . D0: A0 A0 A0 A0 A0 00 00 00 ........
    . D8: 00 00 00 00 00 00 27 00 ......'.
    . E0: 00 00 82 05 02 4D 4F 52 .....MOR
    . E8: 54 47 41 47 45 A0 A0 A0 TGAGE...
    . F0: A0 A0 A0 A0 A0 00 00 00 ........
    . F8: 00 00 00 00 00 00 2D 00 ......-.

We can see from the above data block that this is the last sector in the
chain. Byte 0 contains a zero indicating no forward track. Byte 1 then is a
byte count ($86=134). Byte 134 is the last byte in our data file. Recall that
the status variable (ST) will be set to 64 on the C64 side after byte 134 has
been read.

    . 80: 4E 36 34 2E 56 31 0D xx N64.V1.

The remainder of the block has been padded ($87—$FF). The padding is clearly
recognizable this time around. It has no rhyme or reason but it is still
interesting to say the least. A portion of the C-64 DISK BONUS PACK directory
itself was used to pad the remainder of the data block in question.

    . 80: xx xx xx xx xx xx xx 59 N64.V1.Y
    . 88: 54 53 50 52 49 54 45 53 TSPRITES
    . 90: A0 A0 A0 A0 A0 00 00 00 ........
    . 98: 00 00 00 00 00 00 05 00 ........
    . A0: 00 00 82 07 00 53 4E 4F .....SNO
    . A8: 4F 50 59 20 4D 41 54 48 OPY MATH
    . B0: A0 A0 A0 A0 A0 00 00 00 ........
    . B8: 00 00 00 00 00 00 33 00 ......3.
    . C0: 00 00 82 1D 00 41 4D 4F .....AMO
    . C8: 52 54 20 54 41 42 4C 45 RT TABLE
    . D0: A0 A0 A0 A0 A0 00 00 00 ........
    . D8: 00 00 00 00 00 00 27 00 ......'.
    . E0: 00 00 82 05 02 4D 4F 52 .....MOR
    . E8: 54 47 41 47 45 A0 A0 A0 TGAGE...
    . F0: A0 A0 A0 A0 A0 00 00 00 ........
    . F8: 00 00 00 00 00 00 2D 00 ......-.



## 4.7 Relative File Storage

Relative file types have the most elaborate internal structure. Relative
files are often referred to as random access files. A relative file is
actually two files in one:

1. A sequential data file with records of a fixed length.
2. A file of track and sector pointers called side sectors.

The sequential data file uses fixed length records so that the DOS can
calculate where to find any given record. This makes it possible to position
to a particular record and read or write it without disturbing the rest of
the file. In the jargon of relative files, the length of one record in the
sequential data file is known as the *record size*.

The complete file of track and sectors pointers is called the *side sector
file*. The size of this file depends on the length of the sequential file. In
general it is 1/120th the length of the sequential file (minimum length = 1
block; maximum length = 6 blocks). Each block in this file is known as
a *side sector*. There are really two sets of track and sector pointers in this
file. The larger set is a list of the track and sector numbers of the blocks
used to store the sequential data file (its file chain). The other is a list
of the track and sector numbers of the side sectors (the file chain of the
side sector file).

The purpose of the side sector file is to allow the DOS to find any given
record with remarkable efficiency. One disk read of a side sector is all that
is required to locate the track and sector of the block where a particular
record is stored. Two additional reads may then be required to retrieve a
record itself if it spans two data blocks. This will be explained shortly
when we examine records in more detail.

Remember that sequential data blocks have the following format:

Byte     | Purpose
:------- |:------------------------------------------------------------------
         |
0        | Track of the next block in this file
1        | Sector of the next block in this file
         |
2-255    | 254 bytes of data


Diagrammatically, each block (side sector) in the side sector file looks like
this:

    +-------+--------+---------+--------+--------------+---------------+
    | TRACK | SECTOR | SIDE    | RECORD | TRACK/SECTOR | TRACK/SECTOR  |
    | LINK  | LINK   | SECTOR  | SIZE   | LINKS FOR 6  | LINKS FOR 120 |
    |       |        | NUMBER  |        | SIDE SECTORS | DATA BLOCKS   |
    +-------+--------+---------+--------+--------------+---------------+


Byte    | Purpose
:------ |:-------------------------------------------------------------------
0       | Track of the next side sector
1       | Sector of the next side sector
        |
2       | Side sector number
        |
3       | Record length
        |
4-15    | Track and sector list of the side sector file
        |
        |  4-5  Track and sector of side sector #0
        |  6-7  Track and sector of side sector #1
        |  8-9  Track and sector of side sector #2
        | 10-11 Track and sector of side sector #3
        | 12-13 Track and sector of side sector #4
        | 14-15 Track and sector of side sector #5
        |
16-256  | Track and sector list of 120 data blocks
        |
        | 16-17 Track and sector of data block #1
        | 18-19 Track and sector of data block #2
        | 20-21 Track and sector of data block #3
        |  \
        |  /
        |  \
        |  \/
        | 254-255 Track and sector of data block #120


To help you make some sense out of this, let's begin with the directory entry
for a relative file. Here's the start of the directory of a diskette that has
a relative file stored on it.

             TRACK 18 - SECTOR 01

    . 00: 00 FF 81 11 00 53 43 20 .....SC
    . 08: 31 4D 41 47 20 46 49 4C 1MAG FIL
    . 10: 45 A0 A0 A0 A0 00 00 00 E.......
    . 18: 00 00 00 00 00 00 01 00 ........
    . 20: 00 00 81 11 01 53 43 20 .....SC
    . 28: 32 4D 41 47 20 46 49 4C 2MAG FIL
    . 30: 45 A0 A0 A0 A0 00 00 00 E.......
    . 38: 00 00 00 00 00 00 01 00 ........
    . 40: 00 00 81 11 02 53 43 20 .....SC
    . 48: 33 4D 41 47 20 46 49 4C 3MAG FIL
    . 50: 45 A0 A0 A0 A0 00 00 00 E.......
    . 58: 00 00 00 00 00 00 01 00 ........
    . 60: 00 00 84 11 03 4D 41 47 .....MAG      Here's the entry
    . 68: 20 46 49 4C 45 A0 A0 A0  FILE...      for the REL file:
    . 70: AO A0 A0 A0 A0 11 0D 96 ........
    . 78: 00 00 00 00 00 00 B4 01 ........

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

"MAG FILE" will serve as our demo throughout this section. Let's examine its
directory entry in detail from track 18, sector 1.


    . 60: 00 00 84 11 03 4D 41 47 .....MAG
                ** ** **                        File type and T/S link
    . 68: 20 46 49 4C 45 A0 A0 A0  FILE...
    . 70: AO A0 A0 A0 A0 11 0D 96 ........
    . 78: 00 00 00 00 00 00 B4 01 ........

From the directory entry we can see that "MAG FILE" is a relative file. A
relative file is indicated by an $84 as the file type. The track and sector
pointers in the directory reveal that "MAG FILE" starts at track 17 ($11),
sector 03 ($03). This is the sequential data file portion of the relative
file. It is the beginning of our data.

    . 70: AO A0 A0 A0 A0 11 0D 96 ........
                         ** **                  Side sector information

Side sector information follows the file name. The first side sector begins
at track 17 ($11), sector 13 ($0D).

    . 70: AO A0 A0 A0 A0 11 0D 96 ........
                               **               Record length

In addition, we see our record length ($96=150). Each record in our
sequential data file is 150 bytes long. This is fixed throughout the entire
data file.

    . 78: 00 00 00 00 00 00 B4 01 ........
                            ** **               File length (lo/hi-byte)

Our sample relative file consumes a total of 436 blocks on the diskette (180
+ 1 * 256). (There is still room for expansion.) We can determine the number
of side sectors by simple division. A side sector stores track and sector
pointers for 120 data blocks of our sequential file. To determine the number
of side sectors, simply divide the total number of blocks that appear in the
directory entry by 120 and round up to the next higher integer:

436 / 120 = 3.6 -> 4

Four side sectors are needed to keep track of this much data. To figure out
how many records currently exist requires a little more arithmetic. First we
have to subtract the number of side sectors from the total number of blocks.

436 - 4 = 432

Now we can determine the total number of data bytes currently in use by our
sequential file.

432 * 254 = 109728

Why 254 as a multiplier? Remember that the first two bytes of any data block
are forward track and sector pointers (256 - 2 = 254). We finish our set of
calculations by dividing this total by the fixed record length.

109728 / 150 = 731.52

A total of 731 records exist at the current time in "MAG FILE."

Let's examine the first side sector.

             TRACK 17 - SECTOR 13 SIDE SECTOR #0

    . 00: 0C 13 00 96 11 0D 0C 13 ........  Forward pointer, SS #, size, and
    . 08: 06 10 13 0F 00 00 00 00 ........  6 pairs of side sector pointers
    . 10: 11 03 11 0E 11 04 11 0F ........  120 pairs of data block
    . 18: 11 05 11 10 11 06 11 11 ........  pointers
    . 20: 11 07 11 12 11 08 11 13 ........
    . 28: 11 09 11 14 11 0A 11 0B ........
    . 30: 11 0C 10 00 10 0A 10 14 ........
    . 38: 10 08 10 12 10 06 10 10 ........
    . 40: 10 04 10 0E 10 02 10 0C ........
    . 48: 10 01 10 0B 10 03 10 0D ........
    . 50: 10 05 10 0F 10 07 10 11 ........
    . 58: 10 09 10 13 0F 07 0F 11 ........
    . 60: 0F 05 0F 0F 0F 03 0F 0D ........
    . 68: 0F 01 0F 0B 0F 00 0F 0A ........
    . 70: 0F 14 0F 08 0F 12 0F 06 ........
    . 78: 0F 10 0F 04 0F 0E 0F 02 ........
    . 80: 0F 0C 0F 09 0F 13 0E 07 ........
    . 88: 0E 11 0E 05 0E 0F 0E 03 ........
    . 90: 0E 0D 0E 01 0E 0B 0E 00 ........
    . 98: 0E 0A 0E 14 0E 08 0E 12 ........
    . A0: 0E 06 0E 10 0E 04 0E 0E ........
    . A8: 0E 02 0E 0C 0E 09 0E 13 ........
    . B0: 0D 07 0D 11 0D 05 0D 0F ........
    . B8: 0D 03 0D 0D 0D 01 0D 0B ........
    . C0: 0D 00 0D 0A 0D 14 0D 08 ........
    . C8: 0D 12 0D 06 0D 10 0D 04 ........
    . D0: 0D 0E 0D 02 0D 0C 0D 09 ........
    . D8: 0D 13 0C 07 0C 11 0C 05 ........
    . E0: 0C 0F 0C 03 0C 0D 0C 01 ........
    . E8: 0C 0B 0C 00 0C 0A 0C 14 ........
    . F0: 0C 08 0C 12 0C 06 0C 10 ........
    . F8: 0C 04 0C 0E 0C 02 0C 0C ........


Of primary interest are the first 16 bytes.

    . 00: 0C 13 00 96 11 0D 0C 13 ........
    . 08: 06 10 13 0F 00 00 00 00 ........

Bytes 0 and 1 show us that the next side sector resides at track 12 ($0C),
sector 19 ($13). Byte 2 informs us that this is side sector 0. A maximum of 6
side sectors are used by any one relative file. This is determined solely by
the physical storage capacity of the diskette (664 blocks free after
formatting divided by 120 track and sector pointers in a side sector equals
5.53 side sectors). Side sectors are numbered from 0 to 5. Byte 3 shows us
the record size again (150 bytes). Bytes 5-15 are the track and sector
locations of the six possible side sectors. They can be tabled as follows:


 BYTE | SIDE SECTOR |   TRACK - SECTOR
 ----:|:-----------:|:-------------------:
 4- 5 |      0      | 17 ($11) - 13 ($0D)
 6- 7 |      1      | 12 ($0C) - 19 ($13)
 8- 9 |      2      |  6 ($06) - 16 ($10)
10-11 |      3      | 19 ($13) - 15 ($0F)
12-13 |      4      |  0 ($00) - 0 ($00)
14-15 |      5      |  0 ($00) - 0 ($00)


We can see from the table above that side sectors 4 and 5 have not yet been
allocated. Once our data file expands to encompass more than 480 and 600
sectors, respectively, they will be allocated, provided there is room on the
diskette.

The remaining 240 bytes are track and sector pointers to the first 120 blocks
in the sequential file. From bytes 16 and 17 of side sector 0 we see that our
data begins at track 17 ($11), sector 03 ($03). (This is the track and sector
recorded in the directory itself.) Track 17, sector 03 chains to track 17
($11), sector 14 ($0E) which chains to track 17 ($11), sector 4 ($04) and so
on.

             TRACK 17 - SECTOR 13                   SIDE SECTOR #0

    . 10: 11 03 11 0E 11 04 11 0F
          ** **
    . 18: 11 05 11 10 11 06 11 11 ........
    . 20: 11 07 11 12 11 08 11 13 ........
    . 28: 11 09 11 14 11 0A 11 0B ........
    . 30: 11 0C 10 00 10 0A 10 14 ........
    . 38: 10 08 10 12 10 06 10 10 ........
    . 40: 10 04 10 0E 10 02 10 0C ........
    . 48: 10 01 10 0B 10 03 10 0D ........
    . 50: 10 05 10 0F 10 07 10 11 ........
    . 58: 10 09 10 13 0F 07 0F 11 ........
    . 60: 0F 05 0F 0F 0F 03 0F 0D ........
    . 68: 0F 01 0F 0B 0F 00 0F 0A ........
    . 70: 0F 14 0F 08 0F 12 0F 06 ........
    . 78: 0F 10 0F 04 0F 0E 0F 02 ........
    . 80: 0F 0C 0F 09 0F 13 0E 07 ........
    . 88: 0E 11 0E 05 0E 0F 0E 03 ........
    . 90: 0E 0D 0E 01 0E 0B 0E 00 ........
    . 98: 0E 0A 0E 14 0E 08 0E 12 ........
    . A0: 0E 06 0E 10 0E 04 0E 0E ........
    . A8: 0E 02 0E 0C 0E 09 0E 13 ........
    . B0: 0D 07 0D 11 0D 05 0D 0F ........
    . B8: 0D 03 0D 0D 0D 01 0D 0B ........
    . C0: 0D 00 0D 0A 0D 14 0D 08 ........
    . C8: 0D 12 0D 06 0D 10 0D 04 ........
    . D0: 0D 0E 0D 02 0D 0C 0D 09 ........
    . D8: 0D 13 0C 07 0C 11 0C 05 ........
    . E0: 0C 0F 0C 03 0C 0D 0C 01 ........
    . E8: 0C 0B 0C 00 0C 0A 0C 14 ........
    . F0: 0C 08 0C 12 0C 06 0C 10 ........
    . F8: 0C 04 0C 0E 0C 02 0C 0C ........

Let's trace the remaining side sectors now.

             TRACK 12 - SECTOR 19                   SIDE SECTOR #1

    . 00: 06 10 01 96 11 0D 0C 13 ........
    . 08: 06 10 13 0F 00 00 00 00 ........
    . 10: 0C 09 0B 13 0B 07 0B 11 ........
    . 18: 0B 05 0B 0F 0B 03 0B 0D ........
    . 20: 0B 01 0B 0B 0B 00 0B 0A ........
    . 28: 0B 14 0B 08 0B 12 0B 06 ........
    . 30: 0B 10 0B 04 0B 0E 0B 02 ........
    . 38: 0B 0C 0B 09 0A 13 0A 07 ........
    . 40: 0A 11 0A 05 0A 0F 0A 03 ........
    . 48: 0A 0D 0A 01 0A 0B 0A 00 ........
    . 50: 0A 0A 0A 14 0A 08 0A 12 ........
    . 58: 0A 06 0A 10 0A 04 0A 0E ........
    . 60: 0A 02 0A 0C 0A 09 09 13 ........
    . 68: 09 07 09 11 09 05 09 0F ........
    . 70: 09 03 09 0D 09 01 09 0B ........
    . 78: 09 00 09 0A 09 14 09 08 ........
    . 80: 09 12 09 06 09 10 09 04 ........
    . 88: 09 0E 09 02 09 0C 09 09 ........
    . 90: 08 13 08 07 08 11 08 05 ........
    . 98: 08 0F 08 03 08 0D 08 01 ........
    . A0: 08 0B 08 00 08 0A 08 14 ........
    . A8: 08 08 08 12 08 06 08 10 ........
    . B0: 08 04 08 0E 08 02 08 0C ........
    . B8: 08 09 07 13 07 07 07 11 ........
    . C0: 07 05 07 0F 07 03 07 0D ........
    . C8: 07 01 07 0B 07 00 07 0A ........
    . D0: 07 14 07 08 07 12 07 06 ........
    . D8: 07 10 07 04 07 0E 07 02 ........
    . EO: 07 0C 07 09 06 13 06 07 ........
    . E8: 06 11 06 05 06 0F 06 03 ........
    . F0: 06 0D 06 01 06 0B 06 00 ........
    . F8: 06 0A 06 14 06 08 06 12 ........

Side sector 1 looks OK on this end.

             TRACK 06 - SECTOR 16                   SIDE SECTOR #2

    . 00: 13 0F 02 96 11 0D 0C 13 ........
    . 08: 06 10 13 0F 00 00 00 00 ........
    . 10: 06 06 06 02 06 0C 06 04 ........
    . 18: 06 0E 06 09 05 13 05 07 ........
    . 20: 05 11 05 05 05 0F 05 03 ........
    . 28: 05 0D 05 01 05 0B 05 00 ........
    . 30: 05 0A 05 14 05 08 05 12 ........
    . 38: 05 06 05 10 05 04 05 0E ........
    . 40: 05 02 05 0C 05 09 04 13 ........
    . 48: 04 07 04 11 04 05 04 0F ........
    . 50: 04 03 04 0D 04 01 04 0B ........
    . 58: 04 00 04 0A 04 14 04 08 ........
    . 60: 04 12 04 06 04 10 04 04 ........
    . 68: 04 0E 04 02 04 0C 04 09 ........
    . 70: 03 13 03 07 03 11 03 05 ........
    . 78: 03 0F 03 03 03 0D 03 01 ........
    . 80: 03 0B 03 00 03 0A 03 14 ........
    . 88: 03 08 03 12 03 06 03 10 ........
    . 90: 03 04 03 0E 03 02 03 0C ........
    . 98: 03 09 02 13 02 07 02 11 ........
    . A0: 02 05 02 0F 02 03 02 0D ........
    . A8: 02 01 02 0B 02 00 02 0A ........
    . B0: 02 14 02 08 02 12 02 06 ........
    . B8: 02 10 02 04 02 0E 02 02 ........
    . C0: 02 0C 02 09 01 13 01 07 ........
    . C8: 01 11 01 05 01 0F 01 03 ........
    . D0: 01 0D 01 01 01 0B 01 00 ........
    . D8: 01 0A 01 14 01 08 01 12 ........
    . E0: 01 06 01 10 01 04 01 0E ........
    . E8: 01 02 01 0C 01 09 13 0A ........
    . F0: 13 00 13 0B 13 01 13 0C ........
    . F8: 13 02 13 0D 13 03 13 0E ........

Side sector 2 seems to be in order too.

             TRACK 19 - SECTOR 15                   SIDE SECTOR #3

    . 00: 00 9F 03 96 11 0D 0C 13 ........
    . 08: 06 10 13 0F 00 00 00 00 ........
    . 10: 13 04 13 10 13 06 13 11 ........
    . 18: 13 07 13 12 13 08 13 05 ........
    . 20: 13 09 14 00 14 0A 14 01 ........
    . 28: 14 0B 14 02 14 0C 14 03 ........
    . 30: 14 0D 14 04 14 0E 14 05 ........
    . 38: 14 0F 14 06 14 10 14 07 ........
    . 40: 14 11 14 08 14 12 14 09 ........
    . 48: 15 00 15 0A 15 01 15 0B ........
    . 50: 15 02 15 0C 15 03 15 0D ........
    . 58: 15 04 15 0E 15 05 15 0F ........
    . 60: 15 06 15 10 15 07 15 11 ........
    . 68: 15 08 15 12 15 09 16 00 ........
    . 70: 16 0A 16 01 16 0B 16 02 ........
    . 78: 16 0C 16 03 16 0D 16 04 ........
    . 80: 16 0E 16 05 16 0F 16 06 ........
    . 88: 16 10 16 07 16 11 16 08 ........
    . 90: 16 12 16 09 17 00 17 0A ........
    . 98: 17 01 17 0B 17 02 17 0C ........
    . A0: 00 00 00 00 00 00 00 00 ........
    . A8: 00 00 00 00 00 00 00 00 ........
    . B0: 00 00 00 00 00 00 00 00 ........
    . B8: 00 00 00 00 00 00 00 00 ........
    . C0: 00 00 00 00 00 00 00 00 ........
    . C8: 00 00 00 00 00 00 00 00 ........
    . D0: 00 00 00 00 00 00 00 00 ........
    . D8: 00 00 00 00 00 00 00 00 ........
    . E0: 00 00 00 00 00 00 00 00 ........
    . E8: 00 00 00 00 00 00 00 00 ........
    . F0: 00 00 00 00 00 00 00 00 ........
    . F8: 00 00 00 00 00 00 00 00 ........

Hold it right there please. Bytes 0 and 1 should look familiar by now. Still
thinking? (Hint: End of chain and a byte count.)

    . 00: 00 9F 03 96 11 0D 0C 13 ........
          ** **

Byte 1 of side sector 3 shows a byte count of 159 ($9F). Recall that bytes
16-255 in a side sector are a list of track and sector pointers to 120 data
blocks. As a result, bytes 158 and 159 must be interpreted together. They
point to the last block in our sequential data file in this instance. The
last block is stored on track 23 ($17), sector 12 ($0C). Notice too, that the
remainder of the side sector is padded with nulls. The remaining 96 bytes are
in limbo until our relative file is expanded. Bytes 160 and 161 will then
point to the next track and sector of data and so on. When side sector 3 is
full, a new side sector will be created. Bytes 0 and 1 of side sector 3 will
then point to side sector 4. Bytes 12 and 13 in side sectors 0, 1, and 2 will
also be updated to reflect the creation of side sector 4.

Now let's take a brief glance at the sequential file itself.

             TRACK 17 - SECTOR 03

    . OO: 11 0E 4D 41 47 20 46 49 ..MAG FI
    . 08: 4C 45 0D 20 37 30 39 0D LE. 709.
    . 10: 20 36 0D D4 49 54 4C 45  6..ITLE
    . 18: 0D C3 4F 4D 50 55 54 45 ..OMPUTE
    . 20: 52 0D CD 41 47 41 5A 49 R..AGAZI
    . 28: 4E 45 0D C9 53 53 55 45 NE..SSUE
    . 30: 0D D0 41 47 45 0D C3 4F ..AGE..O
    . 38: 4D 4D 45 4E 54 0D 0D 00 MMENT...
    . 40: 00 00 00 00 00 00 00 00 ........
    . 48: 00 00 00 00 00 00 00 00 ........
    . 50: 00 00 00 00 00 00 00 00 ........
    . 58: 00 00 00 00 00 00 00 00 ........
    . 60: 00 00 00 00 00 00 00 00 ........
    . 68: 00 00 00 00 00 00 00 00 ........
    . 70: 00 00 00 00 00 00 00 00 ........
    . 78: 00 00 00 00 00 00 00 00 ........
    . 80: 00 00 00 00 00 00 00 00 ........
    . 88: 00 00 00 00 00 00 00 00 ........
    . 90: 00 00 00 00 00 00 00 00 ........
    . 98: 20 31 35 30 20 0D 2E 0D  150 ...
    . A0: 2E 0D 2E 0D 2E 0D 2E 0D ........
    . A8: 2E 0D 2E 0D 2E 0D 2E 0D ........
    . B0: 2E 0D 2E 0D 2E 0D 2E 0D ........
    . B8: 2E 0D 2E 0D 2E 0D 2E 0D ........
    . C0: 2E 0D 2E 0D 2E 0D 00 00 ........
    . CB: 00 00 00 00 00 00 00 00 ........
    . D0: 00 00 00 00 00 00 00 00 ........
    . D8: 00 00 00 00 00 00 00 00 ........
    . E0: 00 00 00 00 00 00 00 00 ........
    . E8: 00 00 00 00 00 00 00 00 ........
    . F0: 00 00 00 00 00 00 00 00 ........
    . F8: 00 00 00 00 00 00 00 00 ........

The block reveals a typical sequential file. Bytes 0 and 1 are the chain. The
first data block links to track 17 ($11), sector 14 ($0E). The next 150 bytes
(2 - 151) constitute our first record. Note that the unused bytes within a
record are written as nulls ($00) by the DOS so the record is always a fixed
length. The content of individual records will vary enormously. This is
program dependent so the data block in question contains whatever data was
specified by the program used. This particular record is from a free form
data base. It was reserved to for management information by the main program
and contains the following data:

1. The name of our relative file ("MAG FILE").
2. The number of active records (709).
3. The number of fields in use (6).
4. The field titles (TITLE, COMPUTER, MAGAZINE, ISSUE, PAGE, COMMENT).

In the sequential data file portion of a relative file, the record length
(record size) is constant. In this case, the records are all 150 bytes long.
Record number 2 begins at byte 152 ($98) and will extend on into the next
data block. Two reads would be required to fetch the entire contents of this
record. The first 104 bytes of the record will be found here, but the
remaining 46 are in the next block of the file. Here they are.

             TRACK 17 - SECTOR 14

    . 00: 11 04 00 00 00 00 00 00 ........
    . 08: 00 00 00 00 00 00 00 00 ........
    . 10: 00 00 00 00 00 00 00 00 ........
    . 18: 00 00 00 00 00 00 00 00 ........
    . 20: 00 00 00 00 00 00 00 00 ........
    . 28: 00 00 00 00 00 00 00 00 ........
    . 30: D3 4F 55 4E 44 20 D3 59 .OUND .Y
    . 38: 4E 54 48 45 53 49 53 0D NTHESIS.
    . 40: 41 4C 4C 0D C3 4F 4D 50 ALL..OMP
    . 48: 55 54 45 0D CA 41 4E 20 UTE..AN
    . 50: 38 33 0D 32 36 0D 2E 0D 83.26...
    . 58: 0D 2E 0D 2E 0D 2E 0D 2E ........
    . 60: 0D 2E 0D 2E 0D 2E 0D 2E ........
    . 68: 0D 2E 0D 2E 0D 2E 0D 2E ........
    . 70: 0D 00 00 00 00 00 00 00 ........
    . 78: 00 00 00 00 00 00 00 00 ........
    . 80: 00 00 00 00 00 00 00 00 ........
    . 88: 00 00 00 00 00 00 00 00 ........
    . 90: 00 00 00 00 00 00 00 00 ........
    . 98: 00 00 00 00 00 00 00 00 ........
    . A0: 00 00 00 00 00 00 00 00 ........
    . A8: 00 00 00 00 00 00 00 00 ........
    . B0: 00 00 00 00 00 00 00 00 ........
    . B8: 00 00 00 00 00 00 00 00 ........
    . C0: 00 00 00 00 00 00 D7 52 .......R
    . C8: 49 54 49 4E 47 20 D4 52 ITING .R
    . D0: 41 4E 53 50 4F 52 54 41 ANSPORTA
    . D8: 42 4C 45 20 C2 41 53 49 BLE .ASI
    . E0: 43 0D 41 4C 4C 0D C3 4F C.ALL..0
    . E8: 4D 50 55 54 45 0D CA 41 MPUTE..A
    . F0: 4E 20 38 33 0D 33 36 0D N 83.36.
    . F8: 2E 0D 0D 2E 0D 2E 0D 2E ........

Record number 2 is used again for management information by our data base. It
simply contains the record length. One can see from the number of carriage
returns ($0D) that while only 6 fields are in use, 21 were established by the
main program. One can also see that a blank field from this data base is
stored as a period ($2E = CHR$(46) = "."). Record number 3 begins at byte 48.
It contains our first actual data. It would look like so:

    Title:      Sound Synthesis
    Computer:   All
    Magazine:   Compute (sic)
    Issue:      Jan 83
    Page:       26
    Comment:    (none)

Just out of curiosity let's examine the last two sectors of our sequential
file chain as reported in bytes 156-159 of side sector 3. Why two sectors?
Our fixed length of 150 bytes dictates this. (A fixed record length of 1, 2,
127, or 254 would not span a given sector. The maximum length of a relative
record is 254 bytes. 254 is the only number evenly divisible by these
factors. A record length of 1 or 2 would be rather impractical.)

             TRACK 23 - SECTOR 02

    . 00: 17 0C 00 00 00 00 00 00 ........
    . 08: 00 00 00 00 00 00 00 00 ........
    . 10: 00 00 00 00 00 00 00 00 ........
    . 18: 00 00 00 00 00 00 00 00 ........
    . 20: 00 00 00 00 00 00 00 00 ........
    . 28: 00 00 00 00 00 00 00 00 ........
    . 30: 00 00 00 00 00 00 00 00 ........
    . 38: 00 00 00 00 00 00 00 00 ........
    . 40: 00 00 00 00 00 00 00 00 ........
    . 48: 00 00 00 00 00 00 00 00 ........
    . 50: 00 00 00 00 00 00 00 00 ........
    . 58: 00 00 00 00 00 00 00 00 ........
    . 60: 00 00 00 00 00 00 00 00 ........
    . 68: 00 00 00 00 00 00 00 00 ........
    . 70: 00 00 00 00 00 00 00 00 ........
    . 78: 00 00 00 00 00 00 00 00 ........
    . 80: 00 00 00 00 FF 00 00 00 ........
    . 88: 00 00 00 00 00 00 00 00 ........
    . 90: 00 00 00 00 00 00 00 00 ........
    . 98: 00 00 00 00 00 00 00 00 ........
    . A0: 00 00 00 00 00 00 00 00 ........
    . A8: 00 00 00 00 00 00 00 00 ........
    . B0: 00 00 00 00 00 00 00 00 ........
    . B8: 00 00 00 00 00 00 00 00 ........
    . C0: 00 00 00 00 00 00 00 00 ........
    . C8: 00 00 00 00 00 00 00 00 ........
    . D0: 00 00 00 00 00 00 00 00 ........
    . D8: 00 00 00 00 00 00 00 00 ........
    . E0: 00 00 00 00 00 00 00 00 ........
    . E8: 00 00 00 00 00 00 00 00 ........
    . F0: 00 00 00 00 00 00 00 00 ........
    . F8: 00 00 00 00 00 00 00 00 ........


             TRACK 23 - SECTOR 12

    . 00: 00 B1 00 00 00 00 00 00 ........
    . 08: 00 00 00 00 00 00 00 00 ........
    . 10: 00 00 00 00 00 00 00 00 ........
    . 18: 00 00 00 00 FF 00 00 00 ........
    . 20: 00 00 00 00 00 00 00 00 ........
    . 28: 00 00 00 00 00 00 00 00 ........
    . 30: 00 00 00 00 00 00 00 00 ........
    . 38: 00 00 00 00 00 00 00 00 ........
    . 40: 00 00 00 00 00 00 00 00 ........
    . 48: 00 00 00 00 00 00 00 00 ........
    . 50: 00 00 00 00 00 00 00 00 ........
    . 58: 00 00 00 00 00 00 00 00 ........
    . 60: 00 00 00 00 00 00 00 00 ........
    . 68: 00 00 00 00 00 00 00 00 ........
    . 70: 00 00 00 00 00 00 00 00 ........
    . 78: 00 00 00 00 00 00 00 00 ........
    . 80: 00 00 00 00 00 00 00 00 ........
    . 88: 00 00 00 00 00 00 00 00 ........
    . 90: 00 00 00 00 00 00 00 00 ........
    . 98: 00 00 00 00 00 00 00 00 ........
    . A0: 00 00 00 00 00 00 00 00 ........
    . A8: 00 00 00 00 00 00 00 00 ........
    . B0: 00 00 FF 00 00 00 00 00 ........
    . B8: 00 00 00 00 00 00 00 00 ........
    . C0: 00 00 00 00 00 00 00 00 ........
    . C8: 00 00 00 00 00 00 00 00 ........
    . D0: 00 00 00 00 00 00 00 00 ........
    . D8: 00 00 00 00 00 00 00 00 ........
    . E0: 00 00 00 00 00 00 00 00 ........
    . E8: 00 00 00 00 00 00 00 00 ........
    . F0: 00 00 00 00 00 00 00 00 ........
    . F8: 00 00 00 00 00 00 00 00 ........

An analysis of the preceding two sectors will all but end our discussion on
relative file structure. Bytes 2-131 of track 23, sector 2 are the overflow
of a previous record. Bytes 132-255 of this same track and bytes 2-27 of
track 23, sector 12 make up the next record. This record is empty, as
indicated by a 255 ($FF) in the first byte and nulls in the remaining bytes.
Track 23, sector 12 has no forward chain and a byte count of 177 ($B1). Our
last record in the relative file ends at byte 177 (28-177). What is
interesting is the padding beyond this point:

    . B0: xx xx FF 00 00 00 00 00 ........
    . B8: 00 00 00 00 00 00 00 00 ........
    . C0: 00 00 00 00 00 00 00 00 ........
    . CA: 00 00 00 00 00 00 00 00 ........
    . D0: 00 00 00 00 00 00 00 00 ........
    . D8: 00 00 00 00 00 00 00 00 ........
    . E0: 00 00 00 00 00 00 00 00 ........
    . E8: 00 00 00 00 00 00 00 00 ........
    . F0: 00 00 00 00 00 00 00 00 ........
    . F8: 00 00 00 00 00 00 00 00 ........

We would expect to find all nulls ($00). Byte 178 ($B2), however, shows an
$FF, i.e., the start of a new record. The DOS is one step ahead of the game
when expansion time rolls around. A partial record has already been created
in this instance. The DOS need only calculate the difference between 255 and
the byte count to determine the number of nulls that must follow to complete
the record:

    255 - 177 = 78 bytes already in existence

It then takes the record size to figure out the padding needed:

    Total Record Length - Bytes in Existence = Nulls to Go
    150 - 78 = 72

Slick!

We will close our section on relative file structure by taking a brief look
at how the computer, or you, can locate a particular relative record. Pick a
number, any number. Record number 4 you say. No problem if you know the
record length.

First we find the appropriate side sector.

    4-1 = 3 previous records
    3 * 150 fixed length = 450th starting byte (i.e., 0 - 449 previous bytes)
    450 / 254 = 1.7716535
    INT (1.7716535) + 1 = pointer set 2
    Pointer set 2 / 120 sets of pointers in a side sector = 0.01666667
    INT (0.01666667) = side sector 0

Where in side sector 0 is it? Easy.

    Byte 14 + (pointer set 2 * 2 bytes in a pointer) = byte 18
    Bytes 18 and 19 will contain the track and sector of our record.

Where in the actual data block is it? A piece of cake.

    1.7716535 - INT(1.7716535) = remainder .7716535
    2 (skip over bytes 0 and 1) + (.7716535 * 254 bytes of data) = byte 198

Still a disbeliever? Check it out yourself in the preceding hex dumps of
track 17, sector 13 and track 17, sector 14.



## 4.8 User File Storage

A user file (USR) file is one that is designed by the user. This file type is
designated by an $83 in the directory. Although a user file is a legal
Commodore file type (USR), its use is quite rare. Using a USR file rather
than a more common file type is for showmanship only.

A user file may have the structure of either a sequential file or a program
file if it was created by the DOS. It may be structured entirely differently
if it was created using direct-access techniques described in Chapter 5.
Before you do something rash, remember that the DOS will expect to find the
track and sector links in their normal places. If they are not there, all the
blocks that make up your file will be earmarked as free in the BAM whenever
the disk is validated!



## 4.9 Deleted File Storage

A deleted file (DEL) has a file-type byte of $80 in the directory. This is
not a scratched file ($00), but an undocumented Commodore file type (DEL). It
is extremely rare. Only one vendor has dared use a DEL file on a commercial
product to date. It was not a functional file and was placed on the diskette
to intimidate users as part of a low level protection scheme.

You cannot create a DEL file using an OPEN statement. You can only create a
DEL file by changing the file-type byte of an existing file to $80 as
described in the next section. Since a DEL file is really another file type
in disguise, a DEL file may have the structure of either a sequential file or
a program file. If it has the structure of a program file, it may be loaded
using one of these commands:

    LOAD "FILE NAME,DEL,R",8 (RELOCATED)

    LOAD "FILE NAME,DEL,R",8,1 (NOT RELOCATED)

If a DEL file is structured like a sequential file, it may be opened in read
mode using the following command:

    OPEN 2,8,2,"FILE NAME,DEL,R"



## 4.10 Locked Files

Earlier in this chapter you may have been surprised to see locked files of
various form in the table of legal file types. Locked file types are once
again an undocumented feature of Commodore disk drives. A locked file cannot
be scratched unless it is first unlocked.

Unfortunately, the DOS does not support the locking or unlocking of a file.
You have to do-it-yourself by editing the file-type byte in the directory
entry for that file. The program EDIT TRACK & SECTOR listed in Appendix C
allows you to do this. We will not describe the technique here. See the
section on Unscratching a File in Chapter 8 for instructions on how to edit
the file-type byte. Use the values from the table below, rather than those
listed in Chapter 8, when locking or unlocking a file.


File Type  |  Normal |  Locked
:--------- |:-------:|:--------:
Deleted    | DEL $80 | DEL< $C0
Sequential | SEQ $81 | SEQ< $C1
Program    | PRG $82 | PRG< $C2
User       | USR $83 | USR< $C3
Relative   | REL $84 | REL< $C4


The DOS determines whether or not a file is locked by checking bit 6 of the
file-type byte. If it is set (1), the file is locked. Even if a file has been
locked, it may be renamed or copied using normal disk commands.



## Conclusion

The material covered in this chapter is primarily of academic interest.
However, do not attempt to recover a blown file unless you thoroughly
understand the structure of the directory and how files are stored.



# CHAPTER 5 - DIRECT-ACCESS PROGRAMMING

## 5.1 Introduction to Direct-Access Programming

In Chapter 2 you learned how to use such DOS commands as NEW, SCRATCH, and
VALIDATE, for diskette housekeeping. This chapter describes how to use
another set of DOS commands known as direct-access commands. These commands
are not commonly used in typical programming applications. However, they
allow you to step beyond simple housekeeping chores to develop more powerful
disk utility programs that do such things as:

* Change a disk name or cosmetic ID.
* Display a block availability map (the BAM).
* Display a directory.
* Display a track and sector.
* Chain through a directory entry.
* Edit a track and sector.
* Recover an inadvertently scratched file.
* Recover a damaged diskette.
* Duplicate a diskette.
* Copy a file.
* Catalog a disk library.

As you grow with your 1541, the need for routines of this nature will become
increasingly apparent, if it isn't already. This chapter illustrates the use
of direct-access commands in simple programs. A basic understanding of the
function of these commands is necessary to appreciate the routines found in
subsequent chapters and Appendix C.



## 5.2 Beginning Direct-Access Programming

The 1541 DOS recognizes nine direct-access commands. These direct-access
commands and their functions are listed below.


Direct-Access Command   | Function
:-----------------------|:---------------------------------------------------
Block-Read (U1)         | Read a data block into 1541 RAM.
Buffer-Pointer (B-P)    | Set pointer to any byte in a disk buffer.
Block-Write (U2)        | Write a data block from 1541 RAM to diskette.
Memory-Read (M-R)       | Peek bytes out of 1541 RAM or ROM.
Memory-Write (M-W)      | Poke bytes into 1541 RAM.
Block-Allocate (B-A)    | Set bit in BAM to indicate a sector is in use.
Block-Free (B-F)        | Set bit in BAM to indicate a sector is not in use.
Memory-Execute (M-E)    | Execute a 6502 routine stored in 1541 RAM or ROM.
Block-Execute (B-E)     | Load and execute a 6502 routine in 1541 RAM.


More often than not, direct-access commands complement one another in actual
use. For example, a sector can be read from disk using a U1 command, examined
using a B-P or M-R command, altered using a B-P or M-W command, and rewritten
to disk using a U2 command.

The block-read (U1), buffer-pointer, and block-write (U2) commands are the
easiest to comprehend and, as a result, the most widely used. The memory-read
and memory-write commands represent a more sophisticated level of
direct-access programming and are sometimes used in lieu of the
buffer-pointer command. The block-allocate and block-free commands are used
primarily for the maintenance of random access files. Random access files
were the forerunner of relative files and are rarely used today. The
memory-execute command is used at the guru level of disk programming and
requires a rudimentary knowledge of both machine language and the innards of
the 1541 to implement. The block-execute command, while documented by
Commodore, is almost never used.

In order to use the commands mentioned above you will need to learn how to
open a direct-access data channel. The format of a direct-access OPEN
statement is:

    SYNTAX:     OPEN file#, device#, channel#, "#"

    EXAMPLE:    OPEN 2,8,2,"#"
                OPEN 1,8,14,"#"

where

* file# = the logical file number (1 to 127)
* device# = 8
* channel# = the secondary address of the associated open statement (2 to 14)

Opening a direct-access data channel establishes a communication link between
the C64 and the 1541. In the first example, we opened logical file number 2
on the C64 side to device number 8 with a secondary address of 2 (channel
number 2) on the 1541 side. The only time a channel number is ever referenced
is as part of a direct-access command, e.g., a block-read command (U1). Data
is always read from disk (GET# file#, INPUT# file#,) or written to disk
(PRINT# file#,) by way of the logical file number of the direct-access OPEN
statement NOT the channel number. The logical file number and the channel
number do not have to match as they do in our first OPEN example. They are
two separate entities. The logical file number which resides on the C64 side
passes read or write commands to the channel number on the 1541 side. Any
similarity between the logical file number and the channel number is for
mnemonic purposes only. The second example is a perfectly legal direct-access
OPEN statement. In this instance, we opened logical file number 1 (GET#1,
PRINT#1,) to device number 8 with a secondary address of 14 (channel number
14) on the 1541 side. Whether or not you use mnemonic OPEN statements is
strictly a matter of personal preference.

We will begin our tutorial on direct-access programming with a quick review
of the 1541 format explained in Chapter 3. The table below outlines the range
of track and sector numbers found on a diskette.


  Zone  |    Track | Sector Range | Number of Sectors
:------:|---------:|:------------:|:-----------------:
   1    |   1 - 17 |    0 - 20    |          21
   2    |  18 - 24 |    0 - 18    |          19
   3    |  25 - 30 |    0 - 17    |          18
   4    |  31 - 35 |    0 - 16    |          17


NOTE: If you attempt to access a track less than 1, a track greater than 35,
or a sector out of range for a given track, you will get a DOS error message
number 66, ILLEGAL TRACK OR SECTOR.



## 5.3 Block-Read Command (U1)

The block-read command (U1) transfers the contents of a given track and
sector to an area of disk RAM commonly referred to as a buffer or workspace.
The format of a block- read command (U1) is:

    SYNTAX:
        PRINT# file#, "U1"; channel#; drive#; track; sector

    ALTERNATE:
        PRINT# file#, "U1:" channel#; drive#; track; sector
        PRINT# file#, "U1: channel#, drive#, track, sector"

    EXAMPLE:
        PRINT#15,"U1";2;0;18;0

where

* file# = the logical file number of the command channel
* channel# = the secondary address of the associated open statement
* drive# = 0
* track = 1 to 35
* sector = 0 to the range for a given track

After a given track and sector has been transferred to a buffer with a
block-read command (U1), the buffer pointer is automatically left in
position 255. Bytes 0-255 of the buffer are now accessible from the starting
position, i.e., byte 0. The GET# command is normally used to retrieve one
byte at a time from the buffer by way of the logical file number of the
direct-access OPEN statement. The GET# command is used rather than INPUT#
because the data may contain null bytes, carriage returns and/or line feeds,
commas, colons, or other control characters. When using the GET# command you
must remember to test each incoming byte for equality with the null string
"".A null byte must be converted to CHR$(0) or an ?ILLEGAL QUANTITY ERROR
will result when you try to find the ASCII value of the byte. (The GET#
command fails to make the necessary conversion for you.) The ASCII value of a
byte is used to check for control characters. These characters are
misinterpreted by the INPUT# command. The following example reads the block
from track 18, sector 0 (the BAM) into disk RAM and prints the contents to
the screen.

    100 REM BLOCK-READ (U1)
    110 OPEN 15,8,15
    120 PRINT#15,"I0:"
    130 INPUT#15,EN$,EM$,ET$,ES$
    140 IF EN$<>"00"GOTO 290
    150 OPEN 2,8,2,"#"
    160 PRINT#15,"U1";2;0;18;0
    170 INPUT#15,EN$,EM$,ET$,ES$
    180 IF EN$<>"00"GOTO 270
    190 FOR I=0 TO 255
    200 GET#2,B$
    210 IF B$=""THEN B$=CHR$(0)
    220 A=ASC(B$)
    230 PRINT ST,I,A,
    240 IF A>31 AND A<96 THEN PRINT B$,
    250 PRINT
    260 NEXT I
    270 CLOSE 2
    280 INPUT#15,EN$,EM$,ET$,ES$
    290 CLOSE 15
    300 END


Line Range | Description
:--------- |:----------------------------------------------------------------
110        | Opens logical file number 15 (PRINT#15,) to device 8 with a
           | secondary address of 15 (command channel).
120        | Initializes drive 0.
130-140    | Query the error channel.
150        | Opens logical file number 2 (GET#2,) to device 8 with a
           | secondary address of 2 (channel number 2) letting the 1541
           | assign a buffer area.
160        | Reads the block from drive 0, track 18, sector 0 into channel 2
           | buffer area.
170-180    | Query the error channel.
190        | Begin loop to read 256 bytes.
200        | Transfer a byte from channel 2 buffer area to C 64 memory by way
           | of the GET# command (GET# logical file number not the channel
           | number).
210        | Test for equality with the null string "".
220        | ASCII conversion of a byte.
230        | Print the status variable (ST), our loop counter, and the ASCII
           | value of the byte.
240        | Print the byte if it's within normal ASCII range.
250        | Terminate comma tabulation.
260        | Increment loop counter.
270        | Close logical file number 2.
280        | Suppress the error light.
290        | Close logical file number 15.
300        | End.


An explanation of programming technique is in order here. Initialization
(line 120) is done prior to opening a direct-access data channel (line 150).
Initialization automatically shuts down all direct-access data channels (2
-14) that are open on the 1541 side. The command channel (15) is not
affected. Logical files still remain open on the C64 side, however. Any
attempt to access a data channel after initialization results in a 70, NO
CHANNEL error. The DOS attempts to rewrite the BAM each time a direct-access
channel is closed (line 270). If a diskette is either write protected or DOS
protected, the BAM is not rewritten and the error light remains on until
cleared. Fortunately, no damage has been done to the data on the diskette.
The error light is quite distracting nevertheless. You can suppress the error
light after closing a direct-access data channel simply by inputting the
error number, message, track, and sector via the command channel (line 280).

The alternate formats of the block-read command (U1) in line 160 are:

    PRINT#15,"U1:"2;0;18;0

    PRINT#15,"U1:2,0,18,0"

Although the block-read command (U1) comes in three basic flavors, line 160
uses the preferred format. It will be used in demonstration programs
throughout the chapter for consistency. Alternate formats will appear in
passing.

Additionally, lines 210-220 are often combined into one BASIC statement for
the sake of efficiency:

    A=ASC(B$+CHR$(0))

Recall that lines 210-220 are necessary because the GET# command does not
interpret nulls correctly.



## 5.4 Buffer-Pointer Command (B-P)

The buffer-pointer command allows access to any individual byte in a DOS
buffer. Any byte from position 0 through 255 in the buffer may be read or
overwritten. The format of a buffer-pointer command is:

    SYNTAX:
        PRINT# file#, "B-P"; channel#; byte position

    ALTERNATE:
        PRINT# file#, "B-P:" channel#; byte position
        PRINT# file#, "B-P: channel#, byte position"

    EXAMPLE:
        PRINT#15,"B-P";2;144

where

* file# = the logical file number of the command channel
* channel# = the secondary address of the associated open statement
* byte position = 0 to 255

The following program displays a disk name by reading only bytes 144 to 159
from track 18, sector 0.

    100 REM BUFFER-POINTER
    110 OPEN 15,8,15
    120 PRINT#15,"I0"
    130 INPUT#15,EN$,EM$,ET$,ES$
    140 IF EN$<>"00"GOTO 320
    150 OPEN 2,8,2,"#"
    160 PRINT#15,"U1";2;0;18;0
    170 INPUT#15,EN$,EM$,ET$,ES$
    180 IF EN$<>"00"GOTO 300
    190 PRINT#15,"B-P";2;144
    200 FOR I=1 TO 16
    210 GET#2,B$
    220 IF B$=""THEN B$=CHR$(0)
    230 A=ASC(B$)
    240 IF A>127 THEN A=A-128
    250 IF A<32 OR A>95 THEN A=63
    260 IF A=34 THEN A=63
    270 DN$=DN$+CHR$(A)
    280 NEXT I
    290 PRINT"{DOWN}DISK NAME: ";DN$
    300 CLOSE 2
    310 INPUT#15,EN$,EM$,ET$,ES$
    320 CLOSE 15
    330 END


Line Range | Description
:--------- |:----------------------------------------------------------------
190        | Sets channel 2 pointer to position 144 in the buffer area.
200-280    | Concatenate (build) the disk name one byte at a time by jamming
           | it within printable ASCII range.


    PRINT#15,"B-P:"2;144

    PRINT#15,"B-P:2,144"



## 5.5 Block-Write Command (U2)

The block-write command (U2) writes the data from a DOS buffer to any given
track and sector on a diskette. The format of a block-write command (U2)
parallels that of a block-read command (U1). The format of a block-write
command (U2) is:

SYNTAX:
    PRINT# file#, "U2"; channel#; drive#; track; sector

ALTERNATE:
    PRINT# file#, "U2:" channel#; drive#; track; sector
    PRINT# file#, "U2: channel#, drive#, track, sector"

EXAMPLE:
    PRINT#15,"U2";2;0;18;0

where

* file# = the logical file number of the command channel
* channel# = the secondary address of the associated open statement
* drive# = 0
* track = 1 to 35
* sector = 0 to the range for a given track

The entire contents of a buffer are written to disk during the execution of a
block-write command (U2). The position of the buffer-pointer is irrelevant.
It is not referred to by the DOS during the execution of a block-write
command (U2).

The first program listed below allows a disk name to be changed using a
block-write command (U2). The second example allows you to edit the cosmetic
disk ID that appears in the BAM. NOTE: This program does not change the
formatting ID that is embedded in the header block of every sector.

    100 REM EDIT DISK NAME
    110 FOR I=1TO16
    120 PAD$=PAD$+CHR$(160)
    130 NEXTI
    140 PRINT"{CLR}EDIT DISK NAME - 1541"
    150 PRINT"{DOWN}REMOVE {RVS}WRITE PROTECT TAB{ROFF}"
    160 PRINT"{DOWN}INSERT DISKETTE IN DRIVE"
    170 PRINT"{DOWN}PRESS {RVS}RETURN{ROFF} TO CONTINUE"
    180 GETC$:IFC$=""THEN180
    190 IFC$<>CHR$(13)GOTO180
    200 PRINT"OK"
    210 OPEN15,8,15
    220 PRINT#15,"I0"
    230 INPUT#15,EN$,EM$,ET$,ES$
    240 IFEN$="00"GOTO280
    250 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
    260 CLOSE15
    270 END
    280 OPEN 2,8,2,"#"
    290 PRINT#15,"U1";2;0;18;0
    300 INPUT#15,EN$,EM$,ET$,ES$
    310 PRINT#15,"B-P";2;2
    320 GET#2,B$
    330 IFB$=""THENB$=CHR$(0)
    340 DOS=ASC(B$)
    350 IFDOS=65GOTO390
    360 PRINT"{DOWN}73,CBM DOS V2.6 1541,00,00"
    370 PRINT"{DOWN}{RVS}FAILED{ROFF}"
    380 GOTO720
    390 PRINT#15,"B-P";2;144
    400 FORI=1TO 16
    410 GET#2,B$
    420 IFB$=""THENB$=CHR$(0)
    430 A=ASC(B$)
    440 IFA>127THENA=A-128
    450 IFA<32ORA>95THENA=63
    460 IFA=34THENA=63
    470 ODN$=ODN$+CHR$(A)
    480 NEXTI
    490 PRINT"{DOWN}OLD DISK NAME: ";ODN$
    500 INPUT"{DOWN}NEW DISK NAME";NDN$
    510 IFLEN(NDN$)<>0ANDLEN(NDN$)<17GOTO530
    520 GOTO720
    530 INPUT"{D0WN}ARE YOU SURE (Y/N)  Y{LEFT 3}";Q$
    540 IFQ$<>"Y"GOTO720
    550 NDN$=LEFT$(NDN$+PAD$,16)
    560 PRINT#15,"B-P";2;144
    570 PRINT#2,NDN$;
    580 PRINT#15."U2";2;0;18;0
    590 INPUT#15,EN$,EM$,ET$,ES$
    600 IFEN$="00"GOTO 640
    610 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
    620 PRINT"{DOWN}{RVS}FAILED{ROFF}"
    630 GOTO720
    640 CLOSE2
    650 INPUT#15,EN$,EM$,ET$,ES$
    660 PRINT#15,"I0"
    670 INPUT#15,EN$,EM$,ET$,ES$
    680 CLOSE15
    690 PRINT"{DOWN}DONE!"
    700 END
    710 REM CLOSE
    720 CLOSE2
    730 INPUT#15,EN$,EM$,ET$,ES$
    740 CLOSE15
    750 END


Line Range | Description
:--------- |:----------------------------------------------------------------
280        | Opens logical file number 2 (GET#2, PRINT#2,) to device 8 with a
           | secondary address of 2 (channel number 2) letting the 1541
           | assign a buffer area.
310-380    | Query DOS version.
550        | Pad new diskette name.
560        | Reset channel 2 pointer to position 144.
570        | Overwrite existing disk name in channel 2 buffer area.
580        | Write channel 2 buffer to drive 0, track 18, sector 0.
660        | Update the BAM ($0700-$07FF) to reflect a disk name change.


The alternate formats of the block-write command (U2) in line 580 are:

    PRINT#15,"U2:"2;0;18;0

    PRINT#15,"U2:2,0,18,0"


    100 REM EDIT DISK ID
    110 PRINT"{CLR}EDIT DISK ID - 1541"
    120 PRINT"{DOWN}REMOVE {RVS}WRITE PROTECT TAB{ROFF}"
    130 PRINT"{DOWN}INSERT DISKETTE IN DRIVE"
    140 PRINT"{DOWN}PRESS {RVS}RETURN{ROFF} TO CONTINUE"
    150 GETC$:IFC$=""THEN150
    160 IFC$<>CHR$(13)GOTO150
    170 PRINT"OK"
    180 OPEN 15,8,15
    190 PRINT#15,"I0"
    200 INPUT#15,EN$,EM$,ET$,ES$
    210 IFEN$="00"GOTO250
    220 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
    230 CLOSE15
    240 END
    250 OPEN 2,8,2,"#"
    260 PRINT#15,"U1";2;0;18;0
    270 INPUT#15,EN$,EM$,ET$,ES$
    280 PRINT#15,"B-P";2;2
    290 GET#2,B$
    300 IFB$=""THENB$=CHR$(0)
    310 DOS=ASC(B$)
    320 IFDOS=65GOTO360
    330 PRINT"{DOWN}73,CBM DOS V2.6 1541,00,00"
    340 PRINT"{DOWN}{RVS}FAILED{ROFF}"
    350 GOTO690
    360 PRINT#15,"B-P";2;162
    370 FORI=1TO2
    380 GET#2,B$
    390 IFB$=""THENB$=CHR$(0)
    400 A=ASC(B$)
    410 IFA>127THENA=A-128
    420 IFA<32ORA>95THENA=63
    430 IFA=34THENA=63
    440 ODI$=ODI$+CHR$(A)
    450 NEXTI
    460 PRINT"{DOWN}OLD DISK ID: ";ODI$
    470 INPUT"{DOWN}NEW DISK ID";NDI$
    480 IFLEN(NDI$)<>0ANDLEN(NDI$)<3GOTO500
    490 GOTO690
    500 INPUT"{DOWN}ARE YOU SURE (Y/N)  Y{LEFT 3}";Q$
    510 IFQ$<>"Y"GOTO 690
    520 NDI$=LEFT$(NDI$+CHR$(0),2)
    530 PRINT#15,"B-P";2;162
    540 PRINT#2,NDI$;
    550 PRINT#15,"U2";2;0;18;0
    560 INPUT#15,EN$.EM$,ET$,ES$
    570 IFEN$="00"GOTO610
    580 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
    590 PRINT"{DOWN}{RVS}FAILED{ROFF}"
    600 GOTO690
    610 CLOSE2
    620 INPUT#15,EN$,EM$,ET$,ES$
    630 PRINT#15,"I0"
    640 INPUT#15,EN$,EM$,ET$,ES$
    650 CLOSE15
    660 PRINT"{DOWN}DONE!"
    670 END
    680 REM CLOSE
    690 CLOSE2
    700 INPUT#15,EN$,EM$,ET$,ES$
    710 CLOSE15
    720 END

The alternate formats of the block-write command (U2) in line 550 are:

    PRINT#15,"U2:"2;0;18;0

    PRINT#15,"U2:2,0,18,0"

That's enough about the block-write command (U2) for now.



## 5.6 Memory-Read Command (M-R)

The memory-read command allows you to read the contents of any area of the
1541's RAM or ROM. You must specify in the memory-read command the memory
address of RAM or ROM that you want to read. The format of a memory-read
command is:

    SYNTAX:
        PRINT# file#, "M-R" CHR$(lo-byte) CHR$(hi-byte) CHR$(# of bytes)

    ALTERNATE:
        PRINT# file#, "M-R:" CHR$(lo-byte) CHR$(hi-byte) CHR$(# of bytes)

    EXAMPLE:
        PRINT#15,"M-R"CHR$(0)CHR$(3)

where

* file# = the logical file number of the command channel
* lo-byte = lo-byte of the memory address
* hi-byte = hi-byte of the memory address
* \# of bytes = 1 to 255

The third parameter of the memory-read command, CHR$(# of bytes), is
undocumented by Commodore. The use of the third parameter is always optional.
The default is CHR$(1), i.e., 1 byte.

Typically a block-read command (U1) is issued prior to a memory-read command.
A block-read command (U1) transfers the data that is recorded on a given
track and sector to one of four pages (256 bytes) of RAM. A page of RAM is
called a buffer. When you open a direct-access data channel to the 1541 with
OPEN 2,8,2,"#", the DOS arbitrarily selects one buffer as a workspace for
that channel. As long as you use the GET# file# command or the PRINT# file#
command from the associated OPEN statement you do not need to know which
buffer the DOS is using. The buffer in use is only important when you issue a
memory-read command. You may tell the DOS which buffer area to use in the
direct-access OPEN statement itself. The format for selecting a buffer is:

    SYNTAX:
        OPEN file#, device#, channel#, "# buffer#"

    EXAMPLE:
        OPEN 2,8,2,"#0"

where

* buffer# = 0 to 3

The table below shows how the buffer areas are organized in the 1541.


 Buffer Number |    Address    | Example
:-------------:|:-------------:|:--------------------------------------------
               | $0000 - $00FF | Not available (ZERO PAGE)
               | $0100 - $01FF | Not available (STACK)
               | $0200 - $02FF | Not available (COMMAND BUFFER)
       0       | $0300 - $03FF | OPEN 2,8,2,"#0"
       1       | $0400 - $04FF | OPEN 2,8,2,"#1"
       2       | $0500 - $05FF | OPEN 2,8,2,"#2"
       3       | $0600 - $06FF | OPEN 2,8,2,"#3"
               | $0700 - $07FF | Not available (BAM)


NOTE: Two or more direct-access data channels cannot share the same buffer
area. If you attempt to open a direct-access data channel to a buffer already
in use a 70, a NO CHANNEL error will result.

The GET# command is used following a memory-read command to retrieve the
contents of the buffer you selected. There is one major difference, however.
Bytes are now fetched over the command channel not the logical file number of
the "OPEN file#, device#, channel#, buffer#" statement. Bytes must still be
tested for equality with the null string "" and converted to CHR$(0) if need
be.

The next program selects buffer #0 ($0300 - $03FF) as a workspace and does a
block- read of track 18, sector 0. Bytes are returned to the C64 side from
buffer #0 with memory-read and GET# commands, and printed to the screen.


    100 REM TWO PARAMETER MEMORY-READ
    110 OPEN 15,8,15
    120 PRINT#15,"I0"
    130 INPUT#15,EN$,EM$,ET$,ES$
    140 IF EN$<>"00"GOTO 300
    150 OPEN 2,8,2,"#0"
    160 PRINT#15,"U1";2;0;18;0
    170 INPUT#15,EN$,EM$,ET$,ES$
    180 IF EN$<>"00"GOTO 280
    190 FOR I=0 TO 255
    200 PRINT#15,"M-R"CHR$(I)CHR$(3)
    210 GET#15,B$
    220 IF B$=""THEN B$=CHR$(0)
    230 A=ASC(B$)
    240 PRINT I,A,
    250 IF A>31 AND A<96 THEN PRINT B$,
    260 PRINT
    270 NEXT I
    280 CLOSE 2
    290 INPUT#15,EN$,EM$,ET$,ES$
    300 CLOSE 15
    310 END


Line Range | Description
:--------- |:----------------------------------------------------------------
150        | Opens logical file number 2 to device 8 with a secondary address
           | of 2 assigning buffer number 0 ($0300 - $03FF) as a workspace.
160        | Reads the block from drive 0, track 18, sector 0 into channel 2
           | buffer area ($0300 - $03FF).
190        | Begin loop to read 256 bytes ($0300 - $03FF).
200        | Indexed memory-read command ($0300 - $03FF).
210        | Transfer a byte from channel 2 buffer area to C64 memory via the
           | command channel (GET#15,).


The alternate format of the standard memory-read command in line 200 is:

    PRINT#15,"M-R:"CHR$(I)CHR$(3)

Please note that we deliberately omitted the third parameter of the
memory-read command in the preceding example. The following example
incorporates all three parameters of the memory-read command to read a disk
name.


    100 REM THREE PARAMETER MEMORY-READ
    110 OPEN 15,8,15
    120 PRINT#15,"I0"
    130 INPUT#15,EN$,EM$,ET$,ES$
    140 IF EN$<>"00"GOTO 320
    150 OPEN 2,8,2,"#1"
    160 PRINT#15,"U1";2;0;18;0
    170 INPUT#15,EN$,EM$,ET$,ES$
    180 IF EN$<>"00"GOTO 300
    190 PRINT#15,"M-R"CHR$(144)CHR$(4)CHR$(16)
    200 FOR I=1 TO 16
    210 GET#15,B$
    220 IF B$=""THEN B$=CHR$(0)
    230 A=ASC(B$)
    240 IF A>127 THEN A=A-128
    250 IF A<32 OR A>95 THEN A=63
    260 IF A=34 THEN A=63
    270 DN$=DN$+CHR$(A)
    280 NEXT I
    290 PRINT"{DOWN}DISK NAME: ";DN$
    300 CLOSE 2
    310 INPUT#15,EN$,EM$,ET$,ES$
    320 CLOSE 15
    330 END


Line Range | Description
:--------- |:----------------------------------------------------------------
150        | Opens logical file number 2 to device 8 with a secondary
           | address of 2 assigning buffer number 1 ($0400 - $04FF) as a
           | workspace.
160        | Reads the block from drive 0, track 18, sector 0 into channel 2
           | buffer area ($0400 - $04FF).
190        | Memory-read command ($0490 - $049F).
200        | Begin loop to read 16 characters.
210        | Transfer a byte from channel 2 buffer area to C64 memory over
           | the command channel (GET#15,).


Inclusion of the third memory-read parameter means that we no longer have to
issue a memory-read command to fetch each byte like we did in the first
sample program. Instead, we establish a loop after the memory-read command to
pull a byte in. (See lines 200-280 above.) The alternate format of the three
parameter memory-read command in line 190 is:

    PRINT#15,"M-R:"CHR$(144)CHR$(4)CHR$(16)



## 5.7 Memory-Write Command (M-W)

The memory-write command is the opposite of the memory-read command. Data is
written to a DOS buffer via the command channel. The format of a memory-write
command is:

    SYNTAX:
       PRINT# file#, "M-W" CHR$(lo-byte) CHR$(hi-byte) CHR$(# of bytes) data

    ALTERNATE:
       PRINT# file#, "M-W:" CHR$(lo-byte) CHR$(hi-byte) CHR$(# of bytes) data

    EXAMPLE:
        PRINT#15,"M-W"CHR$(2)CHR$(5)CHR$(2)CHR$(1)CHR$(8)
        PRINT#15,"M-W"CHR$(2)CHR$(5)CHR$(2)CHR$(1)D$

where

* file# = the logical file number of the command channel
* lo-byte = lo-byte of the memory address
* hi-byte = hi-byte of the memory address
* \# of bytes = 1 to 34
* data = a string variable or a CHR$ iteration

A total of 34 data bytes may be written with each issuance of a memory-write
command. Typically only 8, 16, or 32 data bytes are sent out at one time in a
loop as our buffer size (256 bytes) is evenly divisible by these factors. At
the most sophisticated level of disk programming, machine language programs
can be poked into RAM inside the 1541 with a memory-write command and then
executed. (See Chapter 7 for actual programs of this nature.) In practice,
however, one encounters limited use of the memory-write command.

The following example demonstrates the use of the memory-write command. It
allows you to change the load address of a program file. A routine of this
nature would be used to aid in the disassembly of a program that normally
loads into high memory (e.g., $8000-$BFFF) and is already occupied by a
machine language monitor program (SUPERMON64) or ROM.

    100 REM EDIT LOAD ADDRESS
    110 H$="0123456789ABCDEF"
    120 PRINT"{CLR}EDIT LOAD ADDRESS - 1541"
    130 PRINT"{DOWN}REMOVE {RVS}WRITE PROTECT TAB{ROFF}"
    140 PRINT"{DOWN}INSERT DISKETTE IN DRIVE"
    150 PRINT"{DOWN}PRESS {RVS}RETURN{ROFF} TO CONTINUE"
    160 GETC$:IFC$=""THEN160
    170 IFC$<>CHR$(13)GOTO160
    180 PRINT"OK"
    190 OPEN 15,8,15
    200 PRINT#15,"I0"
    210 INPUT#15,EN$,EM$,ET$,ES$
    220 IFEN$="00"GOTO260
    230 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
    240 CLOSE15
    250 END
    260 PRINT#15,"M-R"CHR$(1)CHR$(1)
    270 GET#15,DOS$
    280 IFDOS$=""THENDOS$=CHR$(0)
    290 DOS=ASC(DOS$)
    300 IFDOS=65GOTO330
    310 PRINT"{DOWN}73,CBM DOS V2.6 1541,00,00"
    320 GOTO910
    330 INPUT"{DOWN}FILENAME";F$
    340 IFLEN(F$)<>0ANDLEN(F$)<17GOTO360
    350 GOTO920
    360 OPEN 2,8,2,"0:"+F$+",P,R"
    370 INPUT#15,EN$,EM$,ET$,ES$
    380 IFEN$="00"GOTO400
    390 GOTO940
    400 PRINT#15,"M-R"CHR$(24)CHR$(0)CHR$(2)
    410 GET#15,T$
    420 T=ASC(T$+CHR$(0))
    430 GET#15,S$
    440 S=ASC(S$+CHR$(0))
    450 CLOSE2
    460 INPUT#15,EN$,EM$,ET$,ES$
    470 IFEN$="00"GOTO490
    480 GOTO900
    490 OPEN 2,8,2,"#2"
    500 PRINT#15,"U1";2;0;T;S
    510 INPUT#15,EN$,EM$,ET$,ES$
    520 IFEN$="00"GOTO540
    530 GOTO900
    540 PRINT#15,"M-R"CHR$(2)CHR$(5)CHR$(2)
    550 GET#15,LOW$
    560 LOW=ASC(LOW$+CHR$(0))
    570 GET#15,HIGH$
    580 HIGH=ASC(HIGH$+CHR$(0))
    590 D=HIGH
    600 GOSUB1010
    610 OLA$=HD$
    620 D=LOW
    630 GOSUB1010
    640 OLA$=OLA$+HD$
    650 PRINT"{DOWN}OLD LOAD ADDRESS: ";OLA$
    660 INPUT"{DOWN}NEW LOAD ADDRESS";NLA$
    670 IFLEN(NLA$)=4GOTO690
    680 GOTO960
    690 INPUT"{DOWN}ARE YOU SURE (Y/N)  Y{LEFT 3}";Q$
    700 IFQ$<>"Y"GOTO960
    710 HD$=RIGHT$(NLA$,2)
    720 GOSUB 1060
    730 IFTME=1GOTO960
    740 LOW=D
    750 HD$=LEFT$(NLA$,2)
    760 GOSUB 1060
    770 IFTME=1GOTO960
    780 HIGH=D
    790 PRINT#15,"M-W"CHR$(2)CHR$(5)CHR$(2)CHR$(LOW)CHR$(HIGH)
    800 PRINT#15,"U2";2;0;T;S
    810 INPUT#15,EN$,EM$,ET$,ES$
    820 IFEN$="00"GOTO840
    830 GOTO940
    840 CLOSE2
    850 INPUT#15,EN$,EM$,ET$,ES$
    860 CLOSE15
    870 PRINT"{DOWN}DONE!"
    880 END
    890 REM CLOSE
    900 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
    910 PRINT"{DOWN}{RVS}FAILED{ROFF}"
    920 CLOSE15
    930 END
    940 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
    950 PRINT"{DOWN}{RVS}FAILED{ROFF}"
    960 CLOSE2
    970 INPUT#15,EN$,EM$,ET$,ES$
    980 CLOSE15
    990 END
    1000 REM DECIMAL TO HEXADECIMAL
    1010 H=INT(D/16)
    1020 L=D-(H*16)
    1030 HD$=MID$(H$,H+1,1)+MID$(H$,L+1,1)
    1040 RETURN
    1050 REM HEXADECIMAL TO DECIMAL
    1060 TME=0
    1070 H=0
    1080 FORI=1TO16
    1090 IFLEFT$(HD$,1)=MID$(H$,I,1)THENH=I:I = 16
    1100 NEXTI
    1110 IFH=0THENTME=1:GOTO1200
    1120 H=H-1
    1130 L=0
    1140 FORI=1TO16
    1150 IFRIGHT$(HD$,1)=MID$(H$,I,1)THENL=I:I=16
    1160 NEXTI
    1170 IFL=0THENTME=1:GOTO1200
    1180 L=L-1
    1190 D=H*16+L
    1200 RETURN



Line Range | Description
:--------- |:----------------------------------------------------------------
260-320    | Query DOS version ($0101).
330-350    | Input file name.
360-390    | Opens logical file number 2 to device 8 with a secondary address
           | of 2 for a program read.
400-440    | Fetch file name track ($0018) and sector ($0019).
450        | Close logical file number 2.
490        | Reopens logical file number 2 to device 8 with a secondary
           | address of 2 assigning buffer number 2 ($0500 - $05FF) as a
           | workspace.
500        | Reads the starting block of the filename from drive 0 as
           | specified by $0018 and $0019 into channel 2 buffer area ($0500 -
           | $05FF).
540        | Three parameter memory-read command to fetch two byte load
           | address ($0502 - $0503).
550        | Fetch lo-byte of load address ($0502).
570        | Fetch hi-byte of load address ($0503).
590-640    | Decimal to hexadecimal conversion of load address.
660-700    | Input new load address.
710-780    | Hexadecimal to decimal conversion of new load address.
790        | Memory-write of new two byte load address ($0502 - $0503).
800        | Write channel 2 buffer ($0500 - $05FF) to drive 0, track
           | ($0018), sector ($0019).


The alternate format of the memory-write command in line 790 is:

    PRINT#15,"M-W:"CHR$(2)CHR$(5)CHR$(2)CHR$(LO)CHR$(HI)



## 5.8 Block-Allocate Command (B-A)

The block-allocate command allocates a sector in the BAM as in use. A sector
is allocated by setting its associated bit low (0) on track 18, sector 0.
(Review the coverage on bit mapping in Chapter 4 if necessary.) The DOS will
not write to an allocated sector during a normal write operation such as a
SAVE. However, an allocated sector can be overwritten with a block-write
command (U2). Hence the origin of the term "direct-access."

The format of a block-allocate command is:

    SYNTAX:
        PRINT# file#, "B-A"; drive#; track; sector

    ALTERNATE:
        PRINT# file#, "B-A:"; drive#; track; sector

    EXAMPLE:
        PRINT#15,"B-A";0;1;7

where

* file# = the logical file number of the command channel
* drive# = 0
* track = 1 to 35
* sector = 0 to the range for a given track

The following program allocates every sector on a diskette. Run this program
on a test diskette.

    100 REM BLOCK-ALLOCATE
    110 OPEN 15,8,15
    120 PRINT#15,"I0"
    130 INPUT#15,EN$,EM$,ET$,ES$
    140 IF EN$<>"00"GOTO 310
    150 OPEN 2,8,2,"#"
    160 T=1
    170 S=0
    180 PRINT#15,"B-A";0;T;S
    190 INPUT#15,EN$,EM$,ET$,ES$
    200 IF EN$="00"GOTO 180
    210 IF EN$<>"65"GOTO 330
    220 BA=BA+1
    230 PRINT T,S,BA
    240 T=VAL(ET$)
    250 IF T=0 GOTO 290
    260 IF T=18 THEN T=19:S=0:GOTO 180
    270 S=VAL(ES$)
    280 GOTO 180
    290 CLOSE 2
    300 INPUT#15,EN$,EM$,ET$,ES$
    310 CLOSE 15
    320 END
    330 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
    340 CLOSE 2
    350 INPUT#15,EN$,EM$,ET$,ES$
    360 CLOSE 15
    370 END


Line Range | Description
:--------- |:----------------------------------------------------------------
150        | Open a direct-access channel.
160        | Initialize track to 1.
170        | Initialize sector to 0.
180        | Block-allocate command.
190        | Query error channel.
200        | The track and sector were not allocated.
210        | Something is amiss so bail out.
220        | Counter representing the number of sectors allocated in line
           | 170.
230        | Print track, sector, counter.
240        | The sector just allocated already was but the DOS returns the
           | next available track in the error message (65, NO BLOCK, track,
           | sector).
250        | If the next available track is zero then all 683 blocks on the
           | diskette have been allocated.
260        | Don't allocate the directory.
270        | The DOS returns the next available sector in the error message
           | (65, NO BLOCK, track, sector).
280        | Allocate the next available track and sector.
290        | Close the direct-access channel.
330-370    | Error handler.


The alternate format of the block-allocate command in line 180 is:

    PRINT#15,"B-A:";0;T;S

The opening of a direct-access channel (line 150) is standard form. Why?
Because the BAM is rewritten to a diskette when a direct-access data channel
is closed (line 290).

In reality, though, the BAM is updated on the fly but very erratically. Thus,
opening and closing a direct-access data channel is a good habit to get into.
An ounce of prevention . . .

By the way, what happens when you try to save to a full disk? Error 72, DISK
FULL right? Would you believe error 67, ILLEGAL TRACK OR SECTOR,36,01? Track
36? That's right. An error 72 only occurs during normal write mode (i.e., not
a direct-access write) where at least 1 free block exists at the outset or
the directory is at its physical limit, i.e., 144 active file entries.

A block remains allocated until a diskette is validated. Unless a given track
and sector somehow chains to a directory entry its bit will be freed (1)
during validation. (See the validate command in Chapter 2.) Caution must be
taken to ensure that the block-allocate command does not allocate an unused
sector in the directory. See line 260 above. Once a sector has been allocated
in the directory, it is never deallocated by the DOS, even during a validate.
An allocated directory sector can only be freed under software control.

The following program makes use of the block-allocate command to certify a
formatted diskette. A worst-case binary pattern is written to any sector not
currently in use. Bad sectors, if any, are allocated in the BAM. However,
these bad sectors will be deallocated if the diskette is ever validated.
(Sorry, but that's the nature of the beast.)


    100 REM CERTIFY A DISKETTE - 1541
    110 FORI=1TO32
    120 NULL$=NULL$+CHR$(0)
    130 WRITE$=WRITE$+CHR$(15)
    140 NEXTI
    150 DIMT%(681),S%(681)
    160 PRINT"{CLR}           CERTIFY A DISKETTE"
    170 PRINT"{DOWN}                {RVS}WARNING{ROFF}"
    180 PRINT"{DOWN}{RVS}RANDOM ACCESS{ROFF} AND {RVS}DEL{ROFF} FILES WILL BE LOST"
    190 PRINT"REMOVE {RVS}WRITE PROTECT TAB{ROFF}"
    200 PRINT"{DOWN}INSERT DISKETTE IN DRIVE"
    210 PRINT"{DOWN}PRESS {RVS}RETURN{ROFF} TO CONTINUE"
    220 GETC$:IFC$=""THEN220
    230 IFC$<>CHR$(13)GOTO220
    240 PRINT"OK"
    250 OPEN 15,8,15
    260 PRINT#15,"I0"
    270 INPUT#15,EN$,EM$,ET$,ES$
    280 IFEN$="00"GOTO33O
    290 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
    300 CLOSE15
    310 END
    320 REM BAM
    330 PRINT#15,"M-R"CHR$(0)CHR$(7)CHR$(192)
    340 FORI=0TO191
    350 GET#15,B$
    360 IFB$=""THENB$=CHR$(0)
    370 BAM$=BAM$+B$
    380 NEXTI
    390 D0S=ASC(MID$(BAM$,3,1))
    400 IFDOS=65GOTO460
    410 CLOSE15
    420 PRINT"{DOWN}73,CBM DOS V2.6 1541,00,00"
    430 PRINT"{DOWN}{RVS}FAILED{ROFF}"
    440 END
    450 REM BUFFER
    460 I=0
    470 FORJ=1TO8
    480 PRINT#15,"M-W"CHR$(I)CHR$(4)CHR$(32)WRITE$
    490 I=I+32
    500 NEXTJ
    510 T=1
    520 S=0
    530 C=0
    540 A=0
    550 PRINT#15,"B-A";0;T;S
    560 INPUT#15,EN$,EM$,ET$,ES$
    570 IFEN$="00"GOTO620
    580 T=VAL(ET$)
    590 IFT=0ANDC=0GOTO760
    600 IFT=0GOTO800
    610 S=VAL(ES$)
    620 T$=RIGHT$("0"+RIGHT$(STR$(T),LEN(STR$(T))-1),2)
    630 S$=RIGHT$("0"+RIGHT$(STR$(S),LEN(STR$(S))-1),2)
    640 C=C+1
    650 IFC=1THENPRINT"{UP}  "
    660 PRINT#15,"B-A";0;T;S
    670 PRINT"{HOME}{DOWN 6}{RVS}CERTIFYING{ROFF} TRACK ";T$;" - SECTOR ";S$
    680 PRINT"{DOWN}NUMBER OF SECTORS CERTIFIED    :";C
    690 PRINT"{DOWN}NUMBER OF BAD SECTORS ALLOCATED:";A
    700 GOSUB 1030
    710 IFE=1GOTO550
    720 A=A+1
    730 T%(A)=T
    740 S%(A)=S
    750 GOTO550
    760 CLOSE15
    770 PRINT"{DOWN}ALL SECTORS HAVE BEEN ALLOCATED"
    780 PRINT"{DOWN}{RVS}FAILED{ROFF}"
    790 END
    800 I=0
    810 FORJ=1TO6
    820 PRINT#15,"M-W"CHR$(I)CHR$(4)CHR$(32)MID$(BAM$,I+1,32)
    830 I=I+32
    840 NEXTJ
    850 PRINT#15,"M-W"CHR$(192)CHR$(4)CHR$(32)NULL$
    860 PRINT#15,"M-W"CHR$(224)CHR$(4)CHR$(32)NULL$
    870 T=18
    880 S=0
    890 GOSUB 1030
    900 PRINT#15,"I0"
    910 INPUT#15,EN$,EM$,ET$,ES$
    920 IFA<>0GOTO960
    930 CLOSE15
    940 PRINT"{DOWN}NO BAD SECTORS!"
    950 END
    960 FORI=1TOA
    970 PRINT#15,"B-A";0;T%(I);S%(I)
    980 NEXTI
    990 CLOSE15
    1000 PRINT"{DOWN}DONE!"
    1010 END
    1020 REM SEEK
    1030 JOB=176
    1040 GOSUB 1120
    1050 IFE=1G0TO1080
    1060 RETURN
    1070 REM WRITE
    1080 JOB=144
    1090 GOSUB 1120
    1100 RETURN
    1110 REM JOB QUEUE
    1120 TRY=0
    1130 PRINT#15,"M-W"CHR$(8)CHR$(0)CHR$(2)CHR$(T)CHR$(S)
    1140 PRINT#15,"M-W"CHR$(1)CHR$(0)CHR$(1)CHR$(JOB)
    1150 TRY=TRY+1
    1160 PRINT#15,"M-R"CHR$(1)CHR$(0)
    1170 GET#15,E$
    1180 IFE$=""THENE$=CHR$(0)
    1190 E=ASC(E$)
    1200 IFTRY=500GOTO1220
    1210 IFE>127GOTO1150
    1220 RETURN


Line Range | Description
:--------- |:----------------------------------------------------------------
330-380    | Store the BAM ($0700 - $07A0).
390-440    | Query DOS version.
460-500    | Write worst-case binary pattern to buffer at $0400.
510-540    | Initialize track, sector, and counters.
550        | Block-allocate command.
700        | Write worst-case binary pattern at $0400 - $04FF to a
           | deallocated track and sector.
710        | Query error channel.
720-740    | Error array.
800-890    | Restore the BAM.
960-980    | Allocate any bad sectors in error array.


The alternate format of the two block-allocate commands above are:

    550 PRINT#15,"B-A:";0;T;S

    970 PRINT#15,"B-A:";0;T%(I);S%(I)

Lines 330-380 and 800-890 compensate for a bug in the block-allocate command.
(See Chapter 9 for the lowdown.) Lines 330-380 store an image of the BAM in
C64 RAM. The BAM is restored in lines 800-890. Lines 1020-1230 will be
explained in detail in Chapter 6 on intermediate disk programming techniques.



## 5.9 Block-Free Command (B-F)

The block-free command deallocates (frees) a sector in the BAM. A sector is
deallocated by setting its associated bit high (1) on track 18, sector 0. The
format of a block-free command is:

    SYNTAX:
        PRINT# file#, "B-F"; drive#; track; sector

    ALTERNATE:
        PRINT# file#, "B-F:"; drive#; track; sector

    EXAMPLE:
        PRINT#15,"B-F";0;1;7

where

* file# = the logical file number of the command channel
* drive# = 0
* track = 1 to 35
* sector = 0 to the range for a given track

The following program deallocates every sector on a diskette. Run this
program on a test diskette.

    100 REM BLOCK-FREE
    110 OPEN 15,8,15
    120 PRINT#15,"I0"
    130 INPUT#15,EN$,EM$,ET$,ES$
    140 IF EN$<>"00"GOTO 260
    150 OPEN 2,8,2,"#"
    160 FOR T=1 TO 35
    170 IF T=18 GOTO 240
    180 NS=20+2*(T>17)+(T>24)+(T>30)
    190 FOR S=0 TO NS
    200 PRINT#15,"B-F";0;T;S
    210 BF=BF+1
    220 PRINT T,S,BF
    230 NEXT S
    240 NEXT T
    250 CLOSE 2
    260 INPUT#15,EN$,EM$,ET$,ES$
    270 CLOSE 15
    280 END


Line Range | Description
:--------- |:----------------------------------------------------------------
150        | Open a direct-access channel.
160        | Begin loop for tracks 1 to 35.
170        | Don't deallocate the directory.
180        | Calculate sector range.
190        | Begin loop for sectors 0 to sector range.
200        | Block-free command.
210        | Counter to indicate number of blocks freed.
220        | Print track, sector, counter.
250        | Close the direct-access channel.

The alternate format of the block-free command in line 200 is:

    PRINT#15,"B-F:";0;T;S

The opening and closing of a direct-access channel is essential if the
block-free command is to work correctly. Experimentation in freeing a full
diskette reveals that tracks 34 and 35 still remain allocated if this
procedure is not followed.



## 5.10 Memory-Execute Command (M-E)

The memory-execute command is used to execute any standard ROM routine or, at
the pinnacle of disk programming, a custom machine language program that has
been poked into 1541 RAM. The format of a memory-execute command is:

    SYNTAX:
        PRINT# file#, "M-E" CHR$(lo-byte) CHR$(hi-byte)

    ALTERNATE:
        PRINT# file#, "M-E:" CHR$(lo-byte) CHR$(hi-byte)

    EXAMPLE:
        PRINT#15,"M-E"CHR$(0)CHR$(6)

where

* file# = the logical file number of the command channel
* lo-byte = lo-byte of the RAM or ROM address
* hi-byte = hi-byte of the RAM or ROM address

Machine language programs are poked into 1541 RAM with the memory-write
command. The following primitive program pokes a single RTS instruction to
RAM and executes it.


100 REM MEMORY-EXECUTE
110 OPEN 15,8,15
120 PRINT#15,"M-W"CHR$(O)CHR$(6)CHR$(1)CHR$(96)
130 PRINT#15,"M-E"CHR$(0)CHR$(6)
140 CLOSE15
150 END


Line Range | Description
:--------- |:----------------------------------------------------------------
120        | Write 1 byte ($60) to RAM at $0600.
130        | Execute RTS at $0600.


The alternate format of the memory-execute command in line 130 is:

    PRINT#15,"M-E:"CHR$(0)CHR$(6)

More sophisticated coding is available in Chapter 7. In addition, refer to
Chapter 9 for pertinent information about the execution of standard ROM
routines.



## 5.11 Block-Execute Command (B-E)

The block-execute command is used to execute a machine language program that
resides on diskette. A sector is read into a DOS buffer and executed in a
manner similar to a LOAD and RUN on the C64. The format of a block-execute
command is:

    SYNTAX:
        PRINT# file#, "B-E"; channel#; drive#; track; sector

    ALTERNATE:
        PRINT# file#, "B-E:"; channel#; drive#; track; sector
        PRINT# file#, "B-E: channel#, drive#, track, sector"

    EXAMPLE:
        PRINT#15,"B-E";2;0;1;0

where

* file# = the logical file number of the command channel
* channel# = the secondary address of the associated open statement
* drive# = 0
* track = 1 to 35
* sector = 0 to the range for a given track

The block-execute command could be used in a diagnostic routine but it is
difficult to visualize any other advantage that this command has over a
normal memory-execute command. The following program demonstrates one of the
few block-execute commands you will probably ever see. (lights, camera,
action!) Run this program using a test diskette.

    100 REM BLOCK-EXECUTE
    110 OPEN 15,8,15
    120 PRINT#15,"I0"
    130 INPUT#15,EN$,EM$,ET$,ES$
    140 IF EN$<>"00"GOTO  250
    150 OPEN 2,8,2,"#3"
    160 PRINT#15,"U1";2;0;1;0
    170 INPUT#15,EN$,EM$,ET$,ES$
    180 IF EN$<>"00"GOTO 220
    190 PRINT#15,"M-W"CHR$(0)CHR$(6)CHR$(1)CHR$(96)
    200 PRINT#15,"U2";2;0;1;0
    210 PRINT#15,"M-W"CHR$(0)CHR$(6)CHR$(1)CHR$(0)
    220 PRINT#15,"B-E";2;0;1;0
    230 CLOSE 2
    240 INPUT#15,EN$.EM$,ET$,ES$
    250 CLOSE 15
    260 END

Line Range | Description
:--------- |:----------------------------------------------------------------
150        | Open a direct-access channel specifying buffer number 1
           | ($0600 - $06FF).
160        | Block-read of track 1, sector 0 ($0600 - $06FF).
190        | Write 1 byte ($60) to RAM at $0600.
200        | Block-write to track 1, sector 0 ($0600 - $06FF).
210        | Just to keep us honest.
220        | Block-execute of track 1, sector 0 ($0600 - $06FF).

The alternate formats of the block-execute command in line 220 are:

    PRINT#15,"B-E:";2;0;1;0

    PRINT#15,"B-E:2,0,1,0"



## 5.12 Direct-Access Entomology

We will conclude our discussion of the disk utility command set by pointing
out just a few of the DOS V2.6 direct-access anomalies we've found to date.


### Block-Read (B-R)

Throughout the preceding section we relied solely upon the use of the U1
command to read a sector and not the traditional block-read command (B-R).
Why? The block-read command (B-R) is unreliable, period. When the contents of
a buffer are accessed with the GET# command — surprise, surprise! The number
of bytes returned is a function of the number of the track you accessed. For
example, a block-read (B-R) of any sector

on track 15 will return only 15 bytes before sending an erroneous
End-Or-Identify (EOI). The C64 status variable (ST) is set to 64 and any
further attempt to access the buffer merely returns the same sequence of
bytes over and over and over again. Moreover, the byte in position 0 can only
be accessed when the buffer-pointer is reset to position 0 in line 190. See
for yourself.

    100 REM BLOCK-READ (B-R)
    110 OPEN 15,8,15
    120 PRINT#15,"I0"
    130 INPUT#15,EN$,EM$,ET$,ES$
    140 IF EN$<>"00"GOTO 300
    150 OPEN 2,8,2,"#"
    160 PRINT#15,"B-R";2;0;18;0
    170 INPUT#15,EN$,EM$,ET$,ES$
    180 IF EN$<>"00"GOTO 280
    190 PRINT#15,"B-P";2;0
    200 FOR I=0 TO 255
    210 GET#2,B$
    220 IF B$=""THEN B$=CHR$(0)
    230 A=ASC(B$)
    240 PRINT ST,I,A,
    250 IF A>31 AND A<96 THEN PRINT B$,
    260 PRINT
    270 NEXT I
    280 CLOSE 2
    290 INPUT#15,EN$,EM$,ET$,ES$
    300 CLOSE 15
    310 END

What's even more problematic is the situation that occurs when you do a
block-read (B-R) of a track and sector that was rewritten by the block-write
command (B-W) which is discussed below. The EOI occurs in connection with the
ASCII value of the 0th byte of the sector that was read. Byte 0 contains the
value of the buffer-pointer position at the time the block was written with a
block-write command (B-W). The forward track reference that was originally
there, has been destroyed. The ASCII value of the 0th byte determines how
many characters you can access before the EOI occurs. Run the block-read
(B-R) program listed above against track 1, sector 0 after you've done the
block-write (B-W) experiment listed below on a test disk. Change the track
number in line 160 from an 18 to a 1 like this:

    160 PRINT#15,"B-R";2;0;1;0

After further experimentation on your own, you should have little trouble
understanding why the U1 command replaces the block-read command (B-R). Not
only do user manuals continue to promote the use of the block-read command
(B-R), but they also either ignore the U1 command altogether or simply
mention it in passing without even a hint on how to use it.


### Block-Write (B-W)

Recall that we also neglected to mention the block-write command (B-W) which
we replaced with the U2 command. When you write a block with the block-write
command (B-W) a different kind of dilemma occurs. Bytes 1 through 255 of the
buffer are recorded on diskette correctly but the last position of the
buffer-pointer is written to the 0th byte of the sector (the location of the
forward track pointer). If it's any consolation, the data is still intact.
Too bad the link has been destroyed. Run the following block-write program on
a test diskette.

    100 REM BLOCK-WRITE (B-W)
    110 OPEN 15,8,15
    120 PRINT#15,"I0"
    130 INPUT#15,EN$,EM$,ET$,ES$
    140 IF EN$<>"00"GOTO 260
    150 OPEN 2,8,2,"#"
    160 PRINT#15,"U1";2;0;1;0
    170 INPUT#15,EN$,EM$,ET$,ES$
    180 IF EN$<>"00"GOTO 240
    190 FOR I=0 TO 255
    200 PRINT#2,CHR$(I);
    210 NEXT I
    220 PRINT#15,"B-P";2;6
    230 PRINT#15,"B-W";2;0;1;0
    240 CLOSE 2
    250 INPUT#15,EN$,EM$,ET$,ES$
    260 CLOSE 15
    270 END

Now run the original block-read (U1) program that we wrote using this
diskette. Be sure to change the track in line 160 from an 18 to a 1 as
follows:

    160 PRlNT#15,"U1";2;0;1;0

If all goes according to our diabolical plan, byte 0 will contain a 5 which
is exactly where our buffer-pointer ended up. We arbitrarily set it to
position 6 in line 220 above and 256 bytes later it wraps around to
position 5. (Remember that bytes are numbered from 0 to 255 in a buffer
area.)

Now change the U1 to a B-R in line 160 and run the program again. This time,
only 5 bytes can be accessed before an EOI signal is returned.


### UJ and UI-

Commodore has traditionally had a warm reset buried somewhere in ROM on every
piece of hardware they have manufactured to date. The UJ command is to the
1541 what a SYS 64738 is to the C64, a warm reset. Or rather, that is what
it's supposed to be. The issuance of a UJ command is supposed to reset the
1541. Instead, it hangs the 1541.

Press the RUN/STOP key and RESTORE key in tandem to regain control of the C64
after typing in this one liner in immediate mode.

    OPEN 15,8,15,"UJ" : CLOSE15

Use U: in place of UJ.


The same thing is true for the UI- command although Commodore can't really be
held responsible here. The UI- command was implemented to set the 1541 to
VIC-20 speed, not to take the C64 out to lunch.


### U3 -U9

The *VIC-1541 User's Manual* outlines 7 USER commands that perform a jump to
a particular location in RAM. These USER commands and their respective jump
addresses are:

  User Number | Jump Address
:------------:|:---------------------
   U3 (UC)    | $0500
   U4 (UD)    | $0503
   U5 (UE)    | $0506
   U6 (UF)    | $0509
   U7 (UG)    | $050C
   U8 (UH)    | $050F
   U9 (UI)    | $FFFA


These jump locations are not quite as mystifying as they appear at first
glance. Let's modify our simplistic memory-execute program.

    100 REM U3
    110 OPEN 15,8,15
    120 PRINT#15,"M-W"CHR$(0)CHR$(5)CHR$(1)CHR$(96)
    130 PRINT#15,"U3"
    140 CLOSE15
    150 END

One should be able to discern that any of the first six USER commands, U3 -
U8, could double for a memory-execute command. It is very difficult to
understand why Commodore included six jumps to the $0500 page (buffer number
2). Moreover, the U9 command jumps to $FFFA which is a word table pointing to
the NMI vector. U9 is an alternate reset that bypasses the power-on
diagnostics.

﻿
﻿
# CHAPTER 6 - INTERMEDIATE DIRECT-ACCESS PROGRAMMING

*NOTE: This chapter is not intended for beginners. The reader is assumed to
be relatively familiar with the direct-access programming commands described
in Chapter 5.*

The intermediate level of direct-access programming involves passing requests
directly to the Floppy Disk Controller (FDC) via the job queue. Normally a
1541 command is initiated on the C64 side (e.g., SAVE, a block-read (U1),
etc.). The command is interpreted by the 1541's 6502 Interface Processor (IP)
as a set of simple operations called jobs. (This is analogous to the way the
BASIC interpreter works inside the C64.) These jobs are poked into an area of
1541 RAM called the job queue. Every 10 milliseconds the job queue is scanned
by the Floppy Disk Controller (FDC). If a job request is found the FDC
executes it. The complete set of jobs that the FDC can perform are as follows:

1. Read a sector.
2. Write a sector.
3. Verify a sector.
4. Seek a track.
5. Bump the head to track number 1.
6. Jump to a machine language routine in a buffer.
7. Execute a machine language routine in a buffer.

The hexadecimal and decimal equivalents for each job request as seen by the
FDC are:

 Job Code | Description
:--------:|:-----------
$80 (128) | READ
$90 (144) | WRITE
$A0 (160) | VERIFY
$B0 (176) | SEEK
$C0 (192) | BUMP
$D0 (208) | JUMP
$E0 (224) | EXECUTE

If the FDC finds a job request in the job queue, it attempts to carry it out.
Once the job is complete or aborted the FDC replaces the job code with an
error code. The error codes returned by the FDC to the IP are listed below.
The IP error codes and their respective error messages are what you see when
you read the error channel.

FDC Code | IP Code | Error Message
:------- |:-------:|:--------------------------------------------------------
$01 (1)  |   0     | OK
$02 (2)  |   20    | READ ERROR (header block not found)
$03 (3)  |   21    | READ ERROR (no sync character)
$04 (4)  |   22    | READ ERROR (data block not present)
$05 (5)  |   23    | READ ERROR (checksum error in data block)
$07 (7)  |   25    | WRITE ERROR (write-verify error)
$08 (8)  |   26    | WRITE PROTECT ON
$09 (9)  |   27    | READ ERROR (checksum error in header block)
$0B (11) |   29    | READ ERROR (disk ID mismatch)

A more detailed description of each of these error messages can be found in
Chapter 7.

Suppose that we want to read the contents of a given track and sector. The
command initiated on the C64 side is parsed by the IP. If the syntax is
correct, it is broken down into a job code, a track, and a sector. Depending
upon what buffer has been assigned, the job code is poked into the
corresponding job queue table location. The track and sector for the job are
poked into the corresponding header table locations. The buffers and their
corresponding job queue and header table addresses are outlined below:

Buffer | Address         | Job     Track     Sector
:----- |:--------------- |:--------------------------------------------------
 --    | $0000 - $00FF   | Not available (ZERO PAGE)
 --    | $0100 - $01FF   | Not available (STACK)
 --    | $0200 - $03FF   | Not available (COMMAND BUFFER)
 #0    | $0300 - $03FF   | $0000 $0006 $0007
 #1    | $0400 - $04FF   | $0001 $0008 $0009
 #2    | $0500 - $05FF   | $0002 $000A $000B
 #3    | $0600 - $06FF   | $0003 $000C $000D
 --    | $0700 - $07FF   | Not available (BAM)

For example, a block-read command (U1) issued by the C64 to read the contents
of track 18, sector 0 into buffer number 0 ($0300-$03FF) is checked for a
syntax error and then broken down by the IP. In time, the FDC will find an
$80 (128) at address $0000 in the job queue table, a $12 (18) at address
$0006 in the header table, and a $00 (0) at address $0007 in the header
table. Armed with that information, the FDC will attempt to seek (find) the
track and read the sector. Upon successful completion of the read, the
contents of the sector will be transferred to buffer number 0 ($0300-$03FF)
and a $01 (1) will be returned by the FDC to address $0000. (If the job
request could not be completed for some reason, the job request would be
aborted and the corresponding error code would be stored at address $0000
instead.) Interrogation of the error channel will transfer the IP counterpart
of the FDC error code, the English message, the track number, and the sector
number to the C64 side. If the job request was successful (00,OK,00,00), the
contents of the track and sector could then be retrieved from the buffer at
$0300 - $03FF using a GET# command as described in the previous chapter.

What happens, though, if we bypass the drive's parser routine and attempt to
work the FDC directly ourselves? We thought you'd never ask. Grand and
glorious schemes become possibilities, and that's what intermediate
direct-access programming is all about. Armed with a lookup table of job
codes, a map of the 1541's buffer areas, a track, a sector, and a lookup
table of error codes, the FDC is at your beck and call. Tired of those
horrendous grating noises when your drive errs out? Well wish no more. The
drive does not do a bump (the root of all evil) to reinitialize when you are
working the job queue directly. What more could you ask for? We know. The
code, right?

The following program works the job queue directly to read the block from
track 18, sector 0 into buffer number 0 ($0300 - $03FF) and prints the
contents to the screen. Sound vaguely familiar? It should. It's a
modification of the first program we wrote under beginning direct-access
programming.

    100 REM JOB QUEUE READ
    110 OPEN 15,8,15
    120 PRINT#15,"I0"
    130 INPUT#15,EN$,EM$,ET$,ES$
    140 IF EN$<>"00"GOTO 340
    150 REM SEEK
    160 T=18
    170 S=0
    180 JOB=176
    190 GOSUB 370
    200 IF E<>1 GOTO 340
    210 REM READ
    220 JOB=128
    230 GOSUB 370
    240 IF E<>1 GOTO 340
    250 FOR I=0 TO 255
    260 PRINT#15,"M-R"CHR$(I)CHR$(3)
    270 GET#15,B$
    280 IF B$=""THEN B$=CHR$(0)
    290 A=ASC(B$)
    300 PRINT ST,I,A,
    310 IF A>31 AND A<96 THEN PRINT B$,
    320 PRINT
    330 NEXT I
    340 CLOSE 15
    350 END
    360 REM JOB QUEUE
    370 TRY=0
    380 PRINT#15,"M-W"CHR$(6)CHR$(0)CHR$(2)CHR$(T)CHR$(S)
    390 PRINT#15,"M-W"CHR$(O)CHR$(O)CHR$(1)CHR$(JOB)
    400 TRY=TRY+1
    410 PRINT#15,"M-R"CHR$(0)CHR$(0)
    420 GET#15,E$
    430 IF E$=""THEN E$=CHR$(0)
    440 E=ASC(E$)
    450 IF TRY=500 GOTO 470
    460 IF E>127 GOTO 400
    470 RETURN


** Main Program **

 Line Range   | Description
:------------ |:-------------------------------------------------------------
110           | Open the command channel.
120-140       | Initialize drive.
160           | Initialize track to 18.
170           | Initialize sector to 0.
180-190       | SEEK track 18.
200           | Query FDC error code.
220-230       | READ sector 0 on track 18 into buffer number 0 ($0300-$03FF).
240           | Query FDC error code.
250           | Begin loop to read 256 bytes ($0300-$03FF).
260           | Two parameter memory-read.
270           | Transfer a byte from buffer number 0 to C64 memory by way of
              | the command channel (GET#15,).
280           | Test for equality with the null string "".
290           | ASCII conversion of a byte.
300           | Print the status variable (ST), our loop counter, and the
              | ASCII value of the byte.
310           | Print the byte if it's within printable ASCII range.
320           | Terminate comma tabulation.
330           | Increment loop counter.
340           | Close the command channel.
350           | End.

** Subroutine **

 Line Range   | Description
:------------ |:-------------------------------------------------------------
370           | Initialize try counter.
380           | Stuff the track and sector numbers into buffer number 0's
              | header table ($0006-$0007).
390           | Stuff job code number into buffer number 0's job queue table
              | ($0000).
400-460       | Wait for FDC to complete the job.
470           | Return with FDC error code in hand.


The good news is that working the job queue is not quite as complex as it at
first appears. The subroutine in lines 370-470 is the very heart of the
matter. We simply stuff our track and sector into the header table, our job
code into the job queue table, and wait until the FDC has completed the
operation.

Keep in mind that this example was using buffer number 0 ($0300-$03FF). The
corresponding header table and job queue table addresses were $0006 for the
track, $0007 for the sector, and $0000 for the job code. Please note that
every job code is greater than 127. (Bit 7 is deliberately set high (1).)
Recall that when the FDC has completed a job, the job code is replaced with
an error code. All error codes are less than 128. (Bit 7 is deliberately set
low (0).) Line 460 waits until bit 7 of the job code is set low (0) by the
FDC. If bit 7 is high (1), the FDC is still working so we must continue to
wait (line 410).

Error handling is a bit out of the ordinary too but not all that hard to
comprehend either. An FDC error code of 1 means the job was completed
successfully. Any other number indicates an error.

You will also note a simple hierarchy of jobs in the program listing. Before
we can read a sector (line 220) we must always find the track first (line
180). Now are you ready for this one? Initialization is not necessary at all
when working the job queue directly. Lines 120-140 were included as a force
of habit. Applications like reading damaged or DOS protected diskettes may
dictate that we do not initialize. Now for the bad news.


** WARNING **

Read this passage carefully. Then read it again for good measure. Experience
is a hard teacher — test first, lesson afterward.

1. You must remember at all times when working the job queue that you
   have directly bypassed the parser routine. This is extremely dangerous
   because you have in effect killed all protection built into the 1541
   itself. Let us explain. If by some poor misfortune you elect to do a read
   on track 99, the FDC doesn't know any better and takes off in search of
   track 99. You can physically lock the read/write head if it accidentally
   steps beyond its normal boundaries, i.e., a track less than 1 or a track
   greater than 35. No damage is done to the 1541 itself but if the power-on
   sequence doesn't return the head to center you will have to disassemble
   the drive and reposition the head manually. Exceeding the sector range
   for a given track is no problem, however. The drive will eventually give
   up trying to find a sector out of range and report an FDC error 2 (an IP
   20 error). Tracks are a pain in the stepper motor, however.

2. You must keep your header table locations and your job queue table
   locations straight in relation to the buffer number you are working. If
   they are not in agreement, the drive will go off into never-never land.
   The FDC will either attempt to work a nonexistent job code or seek a
   track and sector out of bounds. Remember the FDC will do exactly what you
   tell it to do. You are at the helm at all times. At the minimum, you will
   have to power off the drive to regain control. Again, no physical damage
   has been done to the 1541 but you may have to reposition the read/write
   head yourself. We know from experience.

3. You should always monitor the job yourself. The try counter in line
   450 is a stopgap measure. Five hundred wait cycles seems like an
   exaggerated figure here. However, you must give the drive adequate time
   to find a desired track and settle down before performing a job. If for
   some reason it cannot complete the job, it usually aborts and returns an
   error code on its own. If it doesn't, something is amiss and a try
   counter may trap it. (You might have to power off the drive to restore
   the status quo.) A try counter is a little like workman's compensation.
   Don't work the job queue without it.

*Now, read these three paragraphs a second time.*

The following program works the job queue directly to read track 18, sector 0
into buffer number 1 ($0400-$04FF). The disk name is returned with a three
parameter memory-read of bytes 144-159 ($0490-$049F). It's another oldie but
goodie.

    100 REM JOB QUEUE READ - DISK NAME
    110 OPEN 15,8,15
    120 PRINT#15,"I0"
    130 INPUT#15,EN$,EM$,ET$,ES$
    140 IF EN$<>"00"GOTO 360
    150 REM SEEK
    160 T=18
    170 S=0
    180 JOB=176
    190 GOSUB 390
    200 IF E<>1 GOTO 360
    210 REM READ
    220 JOB=128
    230 GOSUB 390
    240 IF E<>1 GOTO 360
    250 PRINT#15,"M-R"CHR$(144)CHR$(4)CHR$(16)
    260 FOR I=1 TO 16
    270 GET#15,B$
    280 IF B$=""THEN B$=CHR$(0)
    290 A=ASC(B$)
    300 IF A>127 THEN A=A-128
    310 IF A<32 OR A>95 THEN A=63
    320 IF A=34 THEN A=63
    330 DN$=DN$+CHR$(A)
    340 NEXT I
    350 PRINT"{DOWN}DISK NAME: ";DN$
    360 CLOSE 15
    370 END
    380 REM JOB QUEUE
    390 TRY=0
    400 PRINT#15,"M-W"CHR$(8)CHR$(0)CHR$(2)CHR$(T)CHR$(S)
    410 PRINT#15,"M-W"CHR$(1)CHR$(0)CHR$(1)CHR$(JOB)
    420 TRY=TRY+1
    430 PRINT#15,"M-R"CHR$(1)CHR$(0)
    440 GET#15,E$
    450 IF E$=""THEN E$=CHR$(0)
    460 E=ASC(E$)
    470 IF TRY=500 GOTO 490
    480 IF E>127 GOTO 420
    490 RETURN

 Line Range   | Description
:------------ |:-------------------------------------------------------------
120-140       | Force of habit.
160           | Initialize track to 18.
170           | Initialize sector to 0.
180-190       | SEEK track 18.
200           | Query FDC error code.
220-230       | READ sector 0 on track 18 into buffer number 1 ($0400-$04FF).
240           | Query FDC error code.
250           | Three parameter memory-read ($0490-$049F).
260-340       | Concatenate the disk name one byte at a time by jamming it
              | within printable ASCII range.
390           | Initialize try counter.
400           | Stuff the track and sector number into buffer number 1's
              | header table ($0008-$0009).
410           | Stuff the job code number into buffer number 1's job queue
              | table ($0001).
420-480       | Wait for FDC to complete the job.
490           | Return with FDC error code in hand.


Not much new here except the buffer in use. Let's review the key memory
addresses for working buffer number 1 ($0400-$04FF):

    BUFFER NUMBER 1 = $0400 - $04FF
    TRACK NUMBER    = $0008 (HEADER TABLE)
    SECTOR NUMBER   = $0009 (HEADER TABLE)
    JOB CODE        = $0001 (JOB QUEUE TABLE)

While we're at it, we might as well review the order of jobs for the sake of
posterity. First SEEK a track. Then READ a sector.

The next program incorporates four FDC job codes, namely a SEEK, a READ, a
WRITE, and indirectly a VERIFY. This routine is a modification of the edit
disk name program found in the previous chapter. Keep in mind that we are
working buffer number 2 here ($0500-$05FF). The header table addresses are
$000A for the track and $000B for the sector. The job codes themselves will
be poked into location $0002 in the job queue table.

    100 REM JOB QUEUE READ/WRITE - EDIT DISK NAME
    110 FOR I=1 TO 16
    120 PAD$=PAD$+CHR$(160)
    130 NEXT I
    140 PRINT"{CLR}EDIT DISK NAME - 1541"
    150 PRINT"{DOWN}REMOVE {RVS}WRITE PROTECT TAB{ROFF}"
    160 PRINT"{DOWN}INSERT DISKETTE IN DRIVE"
    170 PRINT"{DOWN}PRESS {RVS}RETURN{ROFF} TO CONTINUE"
    180 GET C$:IF C$=""THEN 180
    190 IF C$<>CHR$(13)GOTO 180
    200 PRINT"OK"
    210 OPEN 15,8,15
    220 PRINT#15,"I0"
    230 INPUT#15,EN$,EM$,ET$,ES$
    240 IF EN$="00"GOTO 290
    250 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
    260 CLOSE 15
    270 END
    280 REM SEEK
    290 T=18
    300 S=0
    310 JOB=176
    320 GOSUB 660
    330 REM READ
    340 JOB=128
    350 GOSUB 660
    360 PRINT#15,"M-R"CHR$(144)CHR$(5)CHR$(16)
    370 FOR I=1 TO 16
    380 GET#15,B$
    390 IF B$=""THEN B$=CHR$(0)
    400 A=ASC(B$)
    410 IF A>127 THEN A=A-128
    420 IF A<32 OR A>95 THEN A=63
    430 IF A=34 THEN A=63
    440 ODN$=ODN$+CHR$(A)
    450 NEXT I
    460 PRINT"{DOWN}OLD DISK NAME: ";ODN$
    470 INPUT"{DOWN}NEW DISK NAME";NDN$
    480 IF LEN(NDN$)<>O AND LEN(NDN$)<17 GOTO 500
    490 GOTO 630
    500 INPUT"{DOWN}ARE YOU SURE (Y/N) Y{LEFT 3}";Q$
    510 IF Q$<>"Y"GOTO 630
    520 NDN$=LEFT$(NDN$+PAD$,16)
    530 PRINT#15,"M-W"CHR$(144)CHR$(5)CHR$(16)NDN$
    540 REM WRITE
    550 JOB=144
    560 GOSUB 660
    570 PRINT#15,"I0"
    580 INPUT#15,EN$,EM$,ET$,ES$
    590 CLOSE 15
    600 PRINT"{DOWN}DONE!"
    610 END
    620 REM CLOSE
    630 CLOSE 15
    640 END
    650 REM JOB QUEUE
    660 TRY=0
    670 PRINT#15,"M-W"CHR$(10)CHR$(0)CHR$(2)CHR$(T)CHR$(S)
    680 PRINT#15,"M-W"CHR$(2)CHR$(0)CHR$(1)CHR$(JOB)
    690 TRY=TRY+1
    700 PRINT#15,"M-R"CHR$(2)CHR$(0)
    710 GET#15,E$
    720 IF E$=""THEN E$=CHR$(0)
    730 E=ASC(E$)
    740 IF TRY=500 GOTO 780
    750 IF E>127 GOTO 690
    760 IF E=1 THEN RETURN
    770 REM ERROR HANDLER
    780 ET$=RIGHT$(STR$(T),LEN(STR$(T))-1)
    790 IF T<10 THEN ET$="0"+ET$
    800 ES$=RIGHT$(STR$(S),LEN(STR$(S))-1)
    810 IF S<10 THEN ES$="0"+ES$
    820 IF E>1 AND E<12 THEN EN$=RIGHT$(STR$(E+18),2):GOTO 840
    830 EN$="02":EM$="?TIME OUT":GOTO 860
    840 IF E=7 OR E=8 THEN EM$="WRITE ERROR":GOTO 860
    850 EM$="READ ERROR"
    860 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
    870 PRINT"{DOWN}{RVS}FAILED{ROFF}"
    880 CLOSE 15
    890 END

 Line Range   | Description
:------------ |:-------------------------------------------------------------
290-320       | SEEK track 18.
340-350       | READ contents of sector 0 from track 18 into buffer number 2
              | ($0500-$05FF).
550-560       | WRITE buffer number 2 ($0500-$05FF) to track 18, sector 0.
770-890       | Error handler.

Lines 100 to 530 should be self explanatory by now. Lines 540-560 are
equivalent to a block-write command (U2). To write a sector via the job queue
we stuff the track and sector in the header table and a $90 (144) into the
job queue table and let her rip.

The error handler, however, is of interest. The conversion from FDC code to
IP code is quite easy. We simply add 18 to the FDC error code (line 820).
Note that we try to restrict all errors within a range of 20 to 29. An FDC
error code of 0 or greater than 11 is indicative that something went
radically wrong. Line 820 arbitrarily reports a ?TIME OUT in this situation.
Speaking from experience, the job just plainly didn't get done. A time out
occurs very rarely, unless of course, one is inspecting a damaged or
DOS-protected diskette.

Line 840 is another highlight. An FDC WRITE ($90) automatically flips to an
FDC VERIFY ($A0) to compare the contents of the buffer against the sector
just written. Kind of neat, isn't it? If the buffer and the sector do not
match, we see an FDC error 7, i.e., an IP error number 25, WRITE ERROR. Since
a VERIFY is done automatically by the FDC, we will not elaborate any further
on this particular job code.

The job code for a BUMP is a $C0 (192). Why anybody would ever want to
implement this job request is beyond us.

A subtle difference exists between the remaining two job codes, a JUMP ($D0)
and an EXECUTE ($E0). A JUMP executes a machine language routine poked into
RAM. No more, no less. Like a BUMP job, it is seldom used. The program that
moves the read/write head in Chapter 9 is the only place where we have ever
found a practical use for it.

An EXECUTE ($E0) is the Rolls Royce of job codes, however. Before a machine
language routine is executed, the FDC makes sure that:

1. The drive is up to speed.
2. The read/write head is on the right track.
3. The read/write head has settled.

The FDC cannot be interrupted when performing an EXECUTE job. Once the FDC
starts to EXECUTE the machine language routine, control is not returned to
the IP until the routine is completed. A runaway routine cannot be debugged
even with BRK instructions. You must power down the 1541 and try to second
guess the side effects of the routine to determine what went wrong.

NOTE: The FDC does not automatically return an error code when the routine is
completed. It is the programmer's responsibility to change the job code in
the job queue table from an EXECUTE ($E0) to an $01 at the end of the
routine. If this is not done, the FDC will find the same EXECUTE request on
its next scan of the job queue and re-run the routine. Infinite regression!

Most of the programs in Chapter 7 make use of the EXECUTE job code in one
form or another. Therefore, example programs will be given there.

﻿
# CHAPTER 7 - DOS PROTECTION

## 7.1 Commodore's Data Encoding Scheme

Before we can enter the netherworld of DOS protection you have to possess a
thorough understanding of how the 1541 records a sector on a diskette. Any
given sector is divided into two contiguous parts, a header block and a data
block. For clarity sake let's review the parts of a sector discussed in
Chapter 3.

Header Block (16 8-bit bytes)

Number of Bytes | Description
:--------------:|:-----------------------------------------
       -        | Sync Character
       1        | Header Block Identifier ($08)
       1        | Header Block Checksum
       1        | Sector Number
       1        | Track Number
       1        | ID LO
       1        | ID HI
       2        | Off Bytes ($0F)
       8        | Header Gap ($55)


Data Block (260 8-bit bytes)

Number of Bytes | Description
:--------------:|:-----------------------------------------
      -         | Sync Character
      1         | Data Block Identifier ($07)
     256        | Data Bytes
      1         | Data Block Checksum
      2         | Off Bytes ($00)
   Variable     | Tail Gap ($55)


The 1541 writes a track on the surface of a diskette as one continuous bit
stream. There are no demagnetized zones between sectors on a track to
delineate where one sector ends and another one begins. Instead, Commodore
relies upon synchronization characters for reference marks. A DOS 2.6 sync
mark can be defined as five 8-bit $FF's written in succession to disk. Note
that a sync mark is recorded at the front end of each header block and each
data block. To differentiate a sync mark from a normal data byte, the 1541
writes to diskette in two modes, a sync mode and a normal write mode.

To appreciate the uniqueness of a sync mark we must first look at how a
normal data byte is recorded. During normal write mode each 8-bit byte is
encoded into 10 bits before it is written to disk. Commodore calls this
encoding scheme *binary to GCR (Group Code Recording) conversion*. The
conversion technique itself is quite straightforward. Each 8-bit byte is
separated into two 4-bit nybbles, a high nybble and a low nybble. For
example, the binary representation of $12 (18) is %00010010. The breakdown of
this 8-bit byte into its two 4-bit nybbles is depicted below:

Hexadecimal |  Binary  | High Nybble | Low Nybble
:----------:|:--------:|:-----------:|:----------:
  $12 (18)  | 00010010 |  0001xxxx   |  xxxx0010

Mathematically speaking, a 4-bit nybble can be decoded into any one of 16
different decimal values ranging from 0 (all bits turned off) to 15 (all bits
turned on) as follows:

    Bit Number  3   2   1   0
    Power of 2  3   2   1   0
    Weight      8   4   2   1

Hence, the 1541's GCR lookup table contains just sixteen 4-bit nybble
equivalencies:

 Hexadecimal |  Binary  |   GCR
:-----------:|:--------:|:-------:
   $0 (0)    |   0000   |  01010
   $1 (1)    |   0001   |  01011
   $2 (2)    |   0010   |  10010
   $3 (3)    |   0011   |  10011
   $4 (4)    |   0100   |  01110
   $5 (5)    |   0101   |  01111
   $6 (6)    |   0110   |  10110
   $7 (7)    |   0111   |  10111
   $8 (8)    |   1000   |  01001
   $9 (9)    |   1001   |  11001
   $A (10)   |   1010   |  11010
   $B (11)   |   1011   |  11011
   $C (12)   |   1100   |  01101
   $D (13)   |   1101   |  11101
   $E (14)   |   1110   |  11110
   $F (15)   |   1111   |  10101

Using the binary to GCR lookup table above, let's walk through the necessary
steps to convert a $12 (18) to GCR form.

STEP 1. Hexadecimal to Binary Conversion

        $12 (18) = 00010010

STEP 2. High Nybble to GCR Conversion

        0001xxxx = $1 (1) = 01011

STEP 3. Low Nybble to GCR Conversion

        xxxx0010 = $2 (2) = 10010

STEP 4. GCR Concatenation

        01011 + 10010 = 0101110010

Two things should stand out when scrutinizing the 1541's binary to GCR lookup
table.

1. No combination of any two 5-bit GCR bytes will ever yield 10 consecutive
   on bits (1s) which is used as the sync mark. Binary to GCR conversion
   eliminates all likelihood that a permutation of normal data bytes can ever
   be mistaken by the read/write electronics for a sync mark.

2. No more than two consecutive off bits (0s) appear in any given 10-bit GCR
   byte or combination of GCR bytes. This latter constraint was imposed for
   accuracy when clocking bits back into the 1541 during a read. (See Chapter
   9 for additional information.)

This brings us full circle to what actually differentiates a sync mark from a
normal data byte. Simply put, a sync mark is 10 or more on bits (1s) recorded
in succession. Only one normal data byte, an $FF (%11111111), can even begin
to fill the shoes of a sync mark. During normal write mode, however, an $FF
would take the following GCR form, 1010110101. Enter sync mode. When the 1541
writes an $FF in sync mode no binary to GCR conversion is done. A single $FF
is only eight consecutive on bits and falls short of the ten consecutive on
bits needed to create a sync character. To remedy this, Commodore writes five
consecutive 8-bit $FFs to disk. This records 40 on bits (1s) in succession.
The overkill is intentional on the DOS's part. Commodore is trying to
guarantee that the 1541 will never have any trouble finding a sync mark
during subsequent reads/writes to a diskette.

Four 8-bit data bytes are converted to four 10-bit GCR bytes at a time by the
1541 DOS. RAM is only an 8-bit storage device though. This hardware
limitation prevents a 10-bit GCR byte from being stored in a single memory
location. Four 10-bit GCR bytes total 40 bits — a number evenly divisible by
our overriding 8-bit constraint. Commodore subdivides the 40 GCR bits into
five 8-bit bytes to solve this dilemma. This explains why four 8-bit data
bytes are converted to GCR form at a time. The following step by step example
demonstrates how this bit manipulation is performed by the DOS.

STEP 1. Four 8-bit Data Bytes
        $08     $10     $00     $12

STEP 2. Hexadecimal to Binary Conversion
        1. Binary Equivalents
            $08      $10      $00      $12
            00001000 00010000 00000000 00010010

STEP 3. Binary to GCR Conversion
        1. Four 8-bit Data Bytes
           00001000 00010000 00000000 00010010
        2. High and Low Nybbles
           0000 1000 0001 0000 0000 0000 0001 0010
        3. High and Low Nybble GCR Equivalents
           01010 01001 01011 01010 01010 01010 01011 10010
        4. Four 10-bit GCR Bytes
           0101001001 0101101010 0101001010 0101110010

STEP 4. 10-bit GCR to 8-bit GCR Conversion
        1. Concatenate Four 10-bit GCR Bytes
           0101001001010110101001010010100101110010
        2. Five 8-bit Subdivisions
           01010010 01010110 10100101 00101001 01110010

STEP 5. Binary to Hexadecimal Conversion
        1. Hexadecimal Equivalents
           01010010 01010110 10100101 00101001 01110010
           $52      $56      $A5      $29      $72

STEP 6. Four 8-bit Data Bytes are Recorded as Five 8-bit GCR Bytes

$08 $10 $00 $12 are recorded as $52 $56 $A5 $29 $72

Four normal 8-bit bytes are always written to diskette as five 8-bit GCR
bytes by the DOS. The 1541 converts these same five 8-bit GCR bytes back to
four normal 8-bit bytes during a read. The steps outlined above still apply
but they are performed in the reverse order. (The appendix contains various
mathematical conversion routines for your use.) In light of the above
discussion, we need to recalculate the number of bytes that are actually
recorded in a sector. We stated in Chapter 3 that a header block was
comprised of eight 8-bit bytes excluding the header gap. This is recorded on
the diskette as ten 8-bit GCR bytes. The formula for determining the actual
number of bytes that are recorded is:

Number of 8-bit GCR Bytes Recorded = (Number of 8-bit Data Bytes/4) * 5

Similarly, a data block consisting of 260 8-bit bytes is written to disk as
325 8-bit GCR bytes. Lest we forget, each sync mark is five 8-bit bytes. We
must also remember to add in the header gap which is held constant at eight
bytes. (Header gap bytes ($55) are not converted to GCR form and serve only
to separate the header block from the data block.) An entire sector is
recorded as 353 bytes not 256 data bytes.

|                     | Data Bytes | GCR Bytes |
|:--------------------|:----------:|:---------:|
|Sync Character ($FF) |    5 *     |     5     |
|Header Block         |    8       |    10     |
|Header Gap ($55)     |    8 *     |     8     |
|Sync Character ($FF) |    5 *     |     5     |
|Data Block           |    260     |    325    |

\* No binary to GCR conversion.

We deliberately excluded the inter-sector (tail) gap in calculating the
number of bytes in a given sector. Why? Because the tail gap is never
referenced again by the DOS once formatting is complete. During formatting
the Floppy Disk Controller (FDC) erases a track by writing 10240 overlapping
8-bit $FFs. Once a track has been erased the FDC writes 2400 8-bit $FFs
(%11111111) followed by 2400 8-bit $55s (%01010101). The intent is to wrap
around the circumference of the track with a clearly discernable on/off
pattern of bytes. The FDC then counts to see how many sync ($FF) and nonsync
($55) bytes were actually written to the track. From this count the FDC
subtracts the total number of bytes that the entire range of sectors in a
given zone will use. The remainder is then divided by the number of sectors
in that zone to determine the size of the tail gap. The algorithm is
analogous to cutting a pie. The tail gap varies not only between tracks due
to a decrease in both circumference and the sector range but between disk
drives as well, due to varying motor speeds. A stopgap measure is
incorporated into the algorithm for the latter reason. If a tail gap is not
computed to be at least four bytes in length, formatting will fail and an
error will be reported. In general, the length of the tail gaps fall into the
ranges tabled below:

Zone |  Tracks  | Number of Sectors | Variable Tail Gap
:---:|:--------:|:-----------------:|:-----------------:
  1  |  1 - 17  |        21         |      4 -7
  2  | 18 - 24  |        19         |      9 - 12
  3  | 25 - 30  |        18         |      5 - 8
  4  | 31 - 35  |        17         |      4 - 8


Note that the values given above do not apply to the highest numbered sector
on a track. The gap between this sector and sector 0 is usually much longer.
We have seen tail gaps in excess of 100 bytes here.

Also note that a header block is never rewritten after formatting is
complete. The data block of a sector, including the sync character, is
completely rewritten every time data is written to that sector. The eight
byte header gap is counted off by the DOS to determine where to start writing
the data block.


## 7.2 Checksums

The only remaining concern we have at this time is how we compute a checksum.
Unlike tape storage where a program file is recorded twice in succession,
data is recorded on diskette only once. In other words, there is no cyclic
redundancy. Checksum comes to the rescue. A single byte checksum or hashtotal
is used by the DOS to determine whether or not an error occurred during a
read of a header block or a data block. A checksum is derived by
Exclusive-ORing (EOR) bytes together. Two bytes are EORed together at one
time by comparing their respective bits. The four possible EOR bit
combinations are shown in the following truth table.


| EOR Truth Table |
|:---------------:|
|   0 EOR 0 = 0   |
|   0 EOR 1 = 1   |
|   1 EOR 0 = 1   |
|   1 EOR 1 = 0   |


A header block checksum is the EOR of: the sector number, the track number,
the ID LO, and the ID HI. (These four bytes serve to differentiate sectors
from one another on a diskette.) A data block checksum is the EOR of all 256
8-bit data bytes in a sector. Recall that a data block normally consists of a
forward track and sector pointer plus 254 data bytes. Please note that bytes
are EORed by the DOS prior to their GCR conversion.

The following example demonstrates how a header block checksum is calculated.
The algorithm for calculating a data block checksum is identical, only longer.


|                | Hexadecimal |  Binary   |
|:---------------|:-----------:|:---------:|
| Sector Number  |  $00 (0)    | 00000000  |
| Track Number   |  $12 (18)   | 00010010  |
| ID LO          |  $58 (88)   | 01011000  |
| ID HI          |  $5A (90)   | 01011010  |


STEP 1. Initialization
EOR $00 (0) With Sector Number

                                                            $00 = 00000000
                                            Sector Number ($00) = 00000000
                                                                 ---------
                                                                  00000000

STEP 2. EOR With Track Number

                                                                  00000000
                                             Track Number ($12) = 00010010
                                                                 ---------
                                                                  00010010

STEP 3. EOR With ID LO

                                                                  00010010
                                                    ID LO ($58) = 01011000
                                                                 ---------
                                                                  01001010

STEP 4. EOR With ID HI

                                                                  01001010
                                                    ID HI ($5A) = 01011010
                                                                 ---------
                                                                  00010000

STEP 5. Binary to Hexadecimal Conversion

        00010000

        $10 (16)

The checksum for $00, $12, $58, and $5A is thus $10 (16). This checksum just
happens to be the header block checksum for track 18, sector 0 on the
1541TEST/DEMO. In addition, the binary to GCR conversion tour presented
earlier was for the first four bytes ($08 $10 $00 $12) of the same header
block.


## 7.3 Description of DOS Error Messages

In Chapter 6 we presented a table of FDC and IP error codes. The following
table outlines the order in which errors are evaluated by the DOS during a
read and a write, respectively.

### READ ERRORS

FDC Job Request|FDC Error Code|IP Error Code| Error Message
:--------------|:------------:|:-----------:|:------------------------------
SEEK           |   $03 (3)    |      21     | No Sync Character
SEEK           |   $02 (2)    |      20     | Header Block Not Found
SEEK           |   $09 (9)    |      27     | Checksum Error in Header Block
SEEK           |   $0B (11)   |      29     | Disk ID Mismatch
READ           |   $02 (2)    |      20     | Header Block Not Found
READ           |   $04 (4)    |      22     | Data Block Not Present
READ           |   $05 (5)    |      23     | Checksum Error in Data Block
READ           |   $01 (1)    |      0      | OK

### WRITE ERRORS

FDC Job Request|FDC Error Code|IP Error Code| Error Message
:--------------|:------------:|:-----------:|:------------------------------
WRITE          |    --  --    |     73      | DOS Mismatch
WRITE          |   $0B (11)   |     29      | Disk ID Mismatch
WRITE          |   $08 (8)    |     26      | Write Protect On
WRITE          |   $07(7)     |     25      | Write-Verify Error
VERIFY         |   $01 (1)    |      0      | OK

Each error is described in greater detail below.

### 21 READ ERROR (NO SYNC CHARACTER)

The FDC could not find a sync mark (10 or more consecutive on bits) on a
given track within a prescribed 20 millisecond time limit. A time out has
occurred.

### 20 READ ERROR (HEADER BLOCK NOT FOUND)

The FDC could not find a GCR header block identifier ($52) after 90 attempts.
The FDC did a seek to a track and found a sync character. The FDC then read
the first GCR byte immediately following it. This GCR byte was compared
against a GCR $52 ($08). The comparison failed and the try counter was
decremented. The FDC waited for another sync character and tried again.
Ninety attempts were made.

### 27 READ ERROR (CHECKSUM ERROR IN HEADER BLOCK)

The FDC found a header block on that track. This header block was read into
RAM and the GCR bytes were converted back to their original binary form. The
FDC then EORed the sector number, the track number, the ID LO, and the ID HI
together. This independent checksum was EORed against the actual checksum
found in the header block itself. If the result of the EOR was not equal
zero, the checksums were not equal. The comparison failed and the FDC
returned a $09 to the error handler.

### 29 READ ERROR (DISK ID MISMATCH)

The IDs recorded in the header block found above did not match the master
copy of the disk id's stored in $0012 and $0013. These zero page memory
addresses are normally updated from track 18 during initialization of a
diskette. Note that they also can be updated by a seek to a track from the
job queue.

### 20 READ ERROR (HEADER BLOCK NOT FOUND)

A GCR image of the header was created using the sector number, the track
number, and the master disk IDs. The FDC attempted to find a header on this
track that matched the GCR image in RAM for that sector. Ninety attempts were
made before this error was reported.

### 22 READ ERROR (DATA BLOCK NOT PRESENT)

The header block for a given track and sector passed the previous five tests
with flying colors. The FDC found the data block sync mark and read the next
325 GCR bytes into RAM. These GCR bytes were converted back into 260 8-bit
binary bytes. The first decoded 8-bit byte was compared against a preset data
block identifier at $0047 and failed to match. Note this zero page memory
address normally contains a $07.

### 23 READ ERROR (CHECKSUM ERROR IN DATA BLOCK)

An independent checksum was calculated for the 256 byte data block converted
above. This checksum did not match the actual checksum read from the diskette.

### 00, OK,00,00

Nothing wrong here.

### 73 DOS MISMATCH (CBM DOS V2.6 1541)

An attempt was made to write to a diskette with a non-compatible format. The
DOS version stored at location $0101 was not a $41. This memory address is
normally updated during initialization by reading byte 2 from track 18,
sector 0.

### 29 READ ERROR (DISK ID MISMATCH)

Same as 29 READ ERROR above but conflicting id's were found during a write
attempt rather than a read. Repeated occurrance of this error on a standard
diskette is indicative of a seating problem or a slow-burning alignment
problem.

### 26 WRITE PROTECT ON

An attempt was made to write to a diskette while the write protect switch is
depressed. Remove the write protect tab from the write protect notch.

### 25 WRITE-VERIFY ERROR

The contents of the data just written to a sector did not match the data in
RAM when they were read back. This was probably caused by a flaw on the
surface of the diskette. The end result was an unclosed file. Validate the
diskette to decorrupt the BAM. (See Chapter 2.)

### 00, OK,00,00

Looking good.


## 7.4 Analyzing a Protected Diskette

Bad sectoring is central to any disk protection scheme. In a nutshell, disk
protection involves the deliberate corruption of a given track or sector. The
authenticity of a diskette is often determined by a short loader program that
reads the corrupted track or sector. In essence the FDC or IP error code is a
password allowing access to the run time module. As a result the loader is
extremely protected. If it can be cracked the program is generally freed from
its bonds. This is easier said than done though. A loader is usually rendered
indecipherable (Coda Obscura) through an autostart feature, the use of
unimplemented 6502 op codes, encryption, or compilation. Frankly speaking,
it's much easier to go after the whole disk. The following passages will
introduce you to the black art of bit copying.

The appendix contains four routines written specifically to assist in the
interrogation of a diskette. They are:

1. Interrogate Formatting IDs
2. Interrogate a Track
3. Shake, Rattle, and Roll
4. Interrogate a Diskette

These four programs tend to complement one another quite well in actual use.
Their uses and limitations are discussed below.

INTERROGATE FORMATTING ID'S returns the embedded disk ID for each track using
a SEEK. Recall that working the job queue prevents the dreaded BUMP. A seek
to a track is deemed successful by the FDC if at least one intact sector can
be found. The header of said sector is stored in zero page from $0016-$001A.
The ASCII equivalents of the ID HI ($0016) and ID LO ($0017) are read and
printed to the CRT if the SEEK was good. At a glance one can determine if a
protected diskette has a blown track or if it has been formatted with
multiple ID's. This latter scheme is less commonly used to date. This program
will not report the integrity of each individual sector. We have other
routines for that task.

There is one severe drawback to this program as it stands. Occasionally the
FDC gets hung up on a track. The SEEK may continue to attempt to find a sync
mark without timing out. (You must power off the 1541 to recover from this
situation.) Experimentation in interrogating unformatted diskettes has
produced the same effect. We surmise that the track in question was passed
over during high-speed duplication. The FDC may in fact be homing in on a
residual bit pattern left over from the manufacturer's certification process.
The program has a built-in fail-safe mechanism for this very reason. Please
take note: Lines 110-140 establish an active track array. All tracks are
presumed active at the onset (line 130). Line 240 tests the integrity of the
track prior to a seek. If a track is inactive (its flag equals 0) the track
is bypassed and the program will work from start to finish. Should the need
arise simply patch in a line that reads:

    145 T(track number)=0

    145 T(17)=0, for example.

If it's any comfort at all, a loader cannot check the integrity of said track
either. The sole function of such a track is to discourage prying eyes.

INTERROGATE A TRACK scans a single track using the job queue. The track is
found with a SEEK and then the integrity of each sector is verified with a
READ. IP error codes are returned to the screen. No BUMP occurs. The routine
may occasionally provide erroneous information. This is a major shortcoming
of a READ from the queue. Certain errors are returned clean as a whistle (22,
23, 27). A partially formatted track (mid-track 21 error) or a smattering of
20 errors tend to throw the FDC into an absolute tizzy. Make note of this.
Repeated runs of the same track often return a different error pattern.
Errors tend to accumulate when a BUMP is overridden. Solution? See the
following paragraph.

SHAKE, RATTLE, AND ROLL also scans a single track by using a U1 command
rather than a direct READ from the job queue. The track is still found by a
SEEK, however, to prevent 29 errors in the event that multiple formatting
played a part in the protection scheme. A 29 error is not an error _per se_.
It is merely a stumbling block. A U1 without a SEEK to a multiple-formatted
diskette will report a DISK ID MISMATCH. Information can be stored on a track
with a different ID. A loader will retrieve it by the same method we're using
here. Errors will force a BUMP so use discretion. Please note that a full
track of 21 errors, 23 errors, or 27 errors does not need to be read with
this routine. After you analyze a track, write the errors down and file your
notes away for archival needs. Your 1541 will love you for it.

INTERROGATE A DISKETTE is the lazy man's routine. It scans an entire diskette
reporting only bad sectors to the screen. The program is essentially
INTERROGATE A TRACK in a loop. Note that you may have to patch around a track
to map the entire diskette. See the example patch above.


## 7.5 Duplicating a Protection Scheme

The following table represents the state of the error. The rank order in
which errors tend to crop up on copy protected diskettes are as follows:

1. 21 ERROR (FULL TRACK)
2. 23 ERROR (SINGLE SECTOR)
3. 23 ERROR (FULL TRACK)
4. 20 ERROR (SINGLE SECTOR)
5. 27 ERROR (FULL TRACK)
6. 29 ERROR (MULTIPLE FORMATTING)
7. 22 ERROR (SINGLE SECTOR)
8. 21 ERROR (PARTIAL TRACK)

Historically speaking, the 21 error (full track) and the 29 error appeared on
the scene concurrently. At the present time, a full track 21 error and a
single sector 23 error are the predominant errors used to corrupt a diskette.
These same two errors are also the easiest to duplicate. The last entry,
partial formatting of a track, is the new kid on the block.

The following 13 programs can be used to duplicate a multitude of errors on a
diskette. They are:

File Name          | Error Number | Error Range
:------------------|:------------:|:-----------------------------------------
21 ERROR           |      21      | FULL TRACK
DESTROY A SECTOR   |    20,21     | SINGLE SECTOR
23A ERROR          |      23      | SINGLE SECTOR
23B ERROR          |      23      |*SINGLE SECTOR
23M ERROR          |      23      | FULL TRACK
20 ERROR           |      20      | SINGLE SECTOR
20M ERROR          |      20      | FULL TRACK
27M ERROR          |      27      | FULL TRACK
22A ERROR          |      22      | SINGLE SECTOR
22B ERROR          |      22      |*SINGLE SECTOR
FORMAT A DISKETTE  |      29      | MULTIPLE FORMATTING ID'S
BACKUP             |      ——      | SINGLE DRIVE BACKUP
COPY               |      ——      | SINGLE FILE COPY

\* Creates an exact duplicate of a bad sector.

Source listings for the machine language routines in these programs are
included as a courtesy to the more advanced reader. The BASIC drivers
themselves are nondescript and will not be explained in depth. It is assummed
that the reader has digested the sections on beginning and intermediate
direct-access programming in Chapters 5 and 6. Algorithms will be briefly
mentioned along with any new techniques and/or limitations that apply.


## 7.6 How to Create 21 Errors on a Full Track

Limitations: None.

Parameters: Track number.

FULL TRACK 21 ERROR

    100 REM 21 ERROR - 1541
    110 PRINT"{CLR}21 ERROR - 1541"
    120 PRINT"{DOWN}INSERT CLONE IN DRIVE"
    130 INPUT"{DOWN}DESTROY TRACK";T
    140 IFT<1ORT>35THENEND
    150 INPUT"{DOWN}ARE YOU SURE  Y{LEFT 3}";Q$
    160 IFQ$<>"Y"THENEND
    170 OPEN 15,8,15
    180 PRINT#15,"I0"
    190 INPUT#15,EN$,EM$,ET$,ES$
    200 IFEN$="00"GOTO250
    210 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
    220 CLOSE15
    230 END
    240 REM SEEK
    250 JOB=176
    260 GOSUB400
    270 FORI=0TO23
    280 READD
    290 D$=D$+CHR$(D)
    300 NEXTI
    310 PRINT#15,"M-W"CHR$(0)CHR$(4)CHR$(24)D$
    320 REM EXECUTE
    330 PRINT"{DOWN}{RVS}DESTROYING{ROFF} TRACK";T
    340 JOB=224
    350 GOSUB400
    360 PRINT"{DOWN}DONE!"
    370 CLOSE15
    380 END
    390 REM JOB QUEUE
    400 TRY=0
    410 PRINT#15,"M-W"CHR$(8)CHR$(0)CHR$(2)CHR$(T)CHR$(0)
    420 PRINT#15,"M-W"CHR$(1)CHR$(0)CHR$(1)CHR$(JOB)
    430 TRY=TRY+1
    440 PRINT#15,"M-R"CHR$(1)CHR$(0)
    450 GET#15,E$
    460 IFE$=""THENE$=CHR$(0)
    470 E=ASC(E$)
    480 IFTRY=500GOTO510
    490 IFE>127GOTO430
    500 RETURN
    510 CLOSE15
    520 PRINT"{DOWN}{RVS}FAILED{ROFF}"
    530 END
    540 REM 21 ERROR
    550 DATA  32,163,253.169, 85,141,  1, 28
    560 DATA 162,255,160, 48, 32,201,253, 32
    570 DATA   0,254,169,  1, 76,105,249,234

FULL TRACK 21 ERROR SOURCE LISTING

    100 REM 21.PAL
    110 REM
    120 OPEN 2,8,2,"@0:21.B,P,W"
    130 REM
    140 SYS40960
    150 ;
    160 .OPT P,02
    170 ;
    180 *= $0500
    190 ;
    200 JSR $FDA3 ; ENABLE WRITE
    210 LDA #$55  ; NON SYNC BYTE
    220 STA $1C01
    230 LDX #$FF
    240 LDY #$48
    250 JSR $FDC9 ; WRITE 18432 NON SYNC BYTES
    260 JSR $FEOO ; ENABLE READ
    270 LDA #$01
    280 JMP $F969

Full Track 21 Error Source Annotation

This routine borrows from FORMT ($FAC7). Prior to formatting a track, the FDC
erases it with sync marks ($FDA3). Experimentation has shown that an RTS from
this ROM entry point would create a track of all 20 errors. Thus we are
forced to trace the FORMT routine a little farther. The subroutine WRTNUM
($FDC3) writes either sync or non-sync bytes. By entering six bytes into
this routine we can establish the number of bytes it writes. A JSR to $FE00
is necessary to re-enable read mode. Otherwise the write head is left on and
it will erase everything in its path. Note that we LDA #$01, the FDC error
code for OK, and JMP to the error handler at $F969 to exit.


## 7.7 How to Create a 21 Error on a Single Sector

Limitations: Preceding sector must be intact (See the annotation below).

Parameters: Track and sector number.

DESTROY A SECTOR

    100 REM DESTROY A SECTOR - 1541
    110 DIMD$(7)
    120 PRINT"{CLR}DESTROY A SECTOR - 1541"
    130 PRINT"{DOWN}INSERT CLONE IN DRIVE"
    140 INPUT"{DOWN}DESTROY TRACK AND SECTOR (T,S)";T,S
    150 IFT<1ORT>35THENEND
    160 NS=20+2*(T>17)+(T>24)+(T>30)
    170 IFS<0ORS>NSTHENEND
    180 INPUT"{DOWN}ARE YOU SURE  Y{LEFT 3}";Q$
    190 IFQ$<>"Y"THENEND
    200 OPEN15,8,15
    210 PRINT#15,"I0"
    220 INPUT#15,EN$,EM$,ET$,ES$
    230 IFEN$="00"GOTO280
    240 PRINT"{DOWN}"EN$","EM$","ET$","ES$
    250 CLOSE15
    260 END
    270 REM SEEK
    280 IFS=0THENS=NS:GOTO300
    290 S=S-1
    300 JOB=176
    310 GOSUB570
    320 REM READ
    330 JOB=128
    340 GOSUB570
    350 FORJ=0TO7
    360 FORI=0TO7
    370 READD
    380 D$(J)=D$(J)+CHR$(D)
    390 NEXTI
    400 NEXTJ
    410 I=0
    420 FORJ=0TO7
    430 PRINT#15,"M-W"CHR$(I)CHR$(5)CHR$(8)D$(J)
    440 I=I+8
    450 NEXTJ
    460 REM EXECUTE
    470 PRINT#15,"M-W"CHR$(2)CHR$(0)CHR$(1)CHR$(224)
    480 PRINT#15,"M-R"CHR$(2)CHR$(0)
    490 GET#15,E$
    500 IFE$=""THENE$=CHR$(0)
    510 E=ASC(E$)
    520 IFE>127GOTO480
    530 CLOSE15
    540 PRINT"{DOWN}DONE!"
    550 END
    560 REM JOB QUEUE
    570 TRY=0
    580 PRINT#15,"M-W"CHR$(8)CHR$(0)CHR$(4)CHR$(T)CHR$(S)CHR$(T)CHR$(S)
    590 PRINT#15,"M-W"CHR$(1)CHR$(0)CHR$(1)CHR$(JOB)
    600 TRY=TRY+1
    610 PRINT#15,"M-R"CHR$(1)CHR$(0)
    620 GET#15,E$
    630 IFE$=""THENE$=CHR$(0)
    640 E=ASC(E$)
    650 IFTRY=500GOTO680
    660 IFE>127GOTO600
    670 IFE=1THENRETURN
    680 CLOSE15
    690 PRINT"{DOWN}{RVS}FAILED{ROFF}"
    700 END
    710 REM DESTROY A SECTOR
    720 DATA 32, 16,245, 32, 86,245,162,  0
    730 DATA 80,254,184,202,208,250,162, 69
    740 DATA 80,254,184,202,208,250,169,255
    750 DATA141,  3, 28,173, 12, 28, 41, 31
    760 DATA  9,192,141, 12, 28,162,  0,169
    770 DATA 85, 80,254,184,141,  1, 28,202
    780 DATA208,247, 80,254, 32,  0,254,169
    790 DATA  1, 76,105,249,234,234,234,234

SINGLE SECTOR 21 ERROR SOURCE LISTING

    100 REM DAS.PAL
    110 REM
    120 OPEN 2,8,2,"@0:DAS.B,P,W"
    130 REM
    140 SYS40960
    150 ;
    160 .OPT P,O2
    170 ;
    180 *= $0500
    190 ;
    200 JSR $F510 ; FIND HEADER
    210 JSR $F556 ; FIND SYNC
    220 ;
    230 ;* WAIT OUT DATA *
    240 ;
    250 LDX #$00
    260 READ1 BVC READ1
    270 CLV
    280 DEX
    290 BNE READ1
    300 ;
    310 LDX #$45
    320 READ2 BVC READ2
    330 CLV
    340 DEX
    350 BNE READ2
    360 ;
    370 LDA #$FF ; DATA DIRECTION OUT
    380 STA $1C03
    390 LDA $1C0C; ENABLE WRITE MODE
    400 AND #$1F
    410 ORA #$C0
    420 STA $1C0C
    430 ;
    440 LDX #$00
    450 LDA #$55
    460 WRITE1 BVC WRITE1
    470 CLV
    480 STA $1C01
    490 DEX
    500 BNE WRITE1
    510 ;
    520 WRITE2 BVC WRITE2
    530 ;
    540 JSR $FEOO ; ENABLE READ MODE
    550 ;
    560 LDA #$01
    570 JMP $F969

Single Sector 21 Error Source Annotation

This routine finds the preceding sector and syncs up to its data block (lines
200-210). Lines 250-350 wait out 325 GCR bytes. We flip to write in lines
370-420 and write out 256 non-sync bytes. This overwrites both sync marks of
the sector that was input. This routine will create a 20 error on a single
sector as it stands. By serendipity, it has a unique side effect. If two
consecutive sectors are destroyed we get a 21 error on both of them. The FDC
times out trying to find one or the other or both. Caution must be used when
spanning a sector range. To duplicate the following scheme we must destroy
sector 0 first followed by sectors 20, 19, and 18 respectively.

|  Sector | Error Number |
|--------:|:------------:|
|       0 |      21      |
|  1 - 17 |      OK      |
| 18 - 20 |      21      |

Repeat. This routine will not create a 21 error on a single sector per se.
Two consecutive sectors must be destroyed.

## 7.8 How to Create a 23 Error on a Single Sector

Limitations: None.

Parameters: Track and sector number.

SINGLE SECTOR 23 ERROR

    100 REM 23A ERROR - 1541
    110 DIMD$(11)
    120 PRINT"{CLR}23 ERROR - 1541"
    130 PRINT"{DOWN}INSERT CLONE IN DRIVE"
    140 INPUT"{DOWN}DESTROY TRACK AND SECTOR (T,S)";T,S
    150 IFT<1ORT>35THENEND
    160 NS=20+2*(T>17)+(T>24)+(T>30)
    170 IFS<0ORS>NSTHENEND
    180 INPUT"{DOWN}ARE YOU SURE  Y{LEFT 3};Q$
    190 IFQ$<>"Y"THENEND
    200 OPEN 15,8,15
    210 PRINT#15,"I0"
    220 INPUT#15,EN$,EM$,ET$,ES$
    230 IFEN$="00"GOTO280
    240 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
    250 CLOSE15
    260 END
    270 REM SEEK
    280 JOB=176
    290 GOSUB550
    300 REM READ
    310 JOB=128
    320 GOSUB550
    330 FORJ=0TO11
    340 FORI=0TO7
    350 READD
    360 D$(J)=D$(J)+CHR$(D)
    370 NEXTI
    380 NEXTJ
    390 I=0
    400 FORJ=0TO11
    410 PRINT#15,"M-W"CHR$(I)CHR$(5)CHR$(8)D$(J)
    420 I=I+8
    430 NEXTJ
    440 REM EXECUTE
    450 PRINT#15,"M-W"CHR$(2)CHR$(0)CHR$(1)CHR$(224)
    460 PRINT#15,"M-R"CHR$(2)CHR$(0)
    470 GET#15,E$
    480 IFE$=""THENE$=CHR$(0)
    490 E=ASC(E$)
    500 IFE>127GOTO460
    510 CLOSE15
    520 PRINT"{DOWN}DONE!"
    530 END
    540 REM JOB QUEUE
    550 TRY=0
    560 PRINT#15,"M-W"CHR$(8)CHR$(0)CHR$(4)CHR$(T)CHR$(S)CHR$(T)CHR$(S)
    570 PRINT#15,"M-W"CHR$(1)CHR$(0)CHR$(1)CHR$(JOB)
    580 TRY=TRY+1
    590 PRINT#15,"M-R"CHR$(1)CHR$(0)
    600 GET#15,E$
    610 IFE$=""THENE$=CHR$(0)
    620 E=ASC(E$)
    630 IFTRY=500GOTO660
    640 IFE>127GOTO580
    650 RETURN
    660 CLOSE15
    670 PRINT"{DOWN}{RVS}FAILED{ROFF}"
    680 END
    690 REM 23 ERROR
    700 DATA 169,  4,133, 49,165, 58,170,232
    710 DATA 138,133, 58, 32,143,247, 32, 16
    720 DATA 245,162,  8, 80,254,184,202,208
    730 DATA 250,169,255,141,  3, 28,173, 12
    740 DATA  28, 41, 31,  9,192,141, 12, 28
    750 DATA 169,255,162,  5,141,  1, 28,184
    760 DATA  80,254,184,202,208,250,160,187
    770 DATA 185,  0,  1, 80,254,184,141,  1
    780 DATA  28,200,208,244,185,  0,  4, 80
    790 DATA 254,184,141,  1, 28,200,208,244
    800 DATA  80,254, 32,  0,254,169,  5,133
    810 DATA  49,169,  1, 76,105,249,234,234

SINGLE SECTOR 23 ERROR SOURCE LISTING

    100 REM 23A.PAL
    110 REM
    120 0PEN2,8,2,"@0:23A.B,P,W"
    130 REM
    140 SYS40960
    150 ;
    160 .OPT P,02
    170 ;
    180 *= $0500
    190 ;
    200 LDA #$04
    210 STA $31
    220 ;
    230 LDA $3A
    240 TAX
    250 INX                             ; INCREMENT CHECKSUM
    260 TXA
    270 STA $3A
    280 ;
    290 JSR $F78F                       ; CONVERT TO GCR
    300 JSR $F510                       ; FIND HEADER #
    310 ;
    320 LDX #$08
    330 WAITGAP BVC WAITGAP             ; WAIT OUT GAP
    340 CLV
    350 DEX
    360 BNE WAITGAP
    370 ;
    380 LDA #$FF                        ; ENABLE WRITE
    390 STA $1C03
    400 LDA $1C0C
    410 AND #$1F
    420 ORA #$C0
    430 STA $1C0C
    440 LDA #$FF
    450 LDX #$05
    460 STA $1C01
    470 CLV
    480 WRITESYNC BVC WRITESYNC
    490 CLV
    500 DEX
    510 BNE WRITESYNC
    520 ;
    530 LDY #$BB
    540 OVERFLOW LDA $0100,Y            ; WRITE OUT OVERFLOW BUFFER
    550 WAIT1 BVC WAIT1
    560 CLV
    570 STA $1C01
    580 INY
    590 BNE OVERFLOW
    600 BUFFER LDA $0400,Y              ; WRITE OUT BUFFER
    610 WAIT2 BVC WAIT2
    620 CLV
    630 STA $1C01
    640 INY
    650 BNE BUFFER
    660 WAIT3 BVC WAIT3
    670 ;
    680 JSR $FEOO                       ; ENABLE READ
    690 ;
    700 LDA #$05
    710 STA $31
    720 LDA #$01
    730 JMP $F969

Single Sector 23 Error Source Annotation

This routine borrows from WRIGHT ($F56E). Our entry point is 12 bytes into the
routine. This bypasses the write protect test and the computation of the
checksum. The driver routine reads the sector into $0400-$04FF. Lines 200-210
of the source listing set the indirect buffer pointer to this workspace. The
checksum is next incremented at $003A. Buffer number 1 is converted to GCR
form. Recall that 260 data bytes are converted into 325 8-bit GCR bytes. More
than one buffer is used to store the GCR image. The first 69 GCR bytes are
stored in an overflow buffer at $01BB-$01FF. The remaining 256 bytes are found
at $0400-$04FF. We sync up to the appropriate sector in line 300, count off the
eight byte header gap, and flip to write mode. Five $FFs are then written to
disk (the sync mark) followed first by the overflow buffer and then the regular
buffer. We restore the indirect buffer pointer at $0031 to a $05 and jump to
the error handler with a $01 in hand.

## 7.9 How to Duplicate a 23 Error on a Single Sector

Limitations: None (Requires disk swapping).

Parameters: Track and sector number.

DUPLICATE A SINGLE SECTOR 23 ERROR

    100 REM DUPLICATE A 23 ERROR - 1541
    110 DIMD$(10)
    120 PRINT"{CLR}DUPLICATE A 23 ERROR - 1541"
    130 PRINT"{DOWN}INSERT MASTER DISKETTE IN DRIVE"
    140 INPUT"{DOWN}READ TRACK AND SECTOR (T,S)";T,S
    150 IFT<1ORT>35THENEND
    160 NS=20+2*(T>17)+(T>24)+(T>30)
    170 IFS<0ORS>NSTHENEND
    180 INPUT"{DOWN}ARE YOU SURE  Y{LEFT 3}";Q$
    190 IFQ$<>"Y"THENEND
    200 OPEN15,8,15
    210 PRINT#15,"I0"
    220 INPUT#15,EN$,EM$,ET$,ES$
    230 IFEN$="00"GOTO280
    240 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
    250 CLOSE15
    260 END
    270 REM SEEK
    280 JOB=176
    290 GOSUB650
    300 REM READ
    310 JOB=128
    320 GOSUB650
    330 CLOSE15
    340 PRINT"{DOWN}INSERT CLONE IN DRIVE"
    350 PRINT"{DOWN}PRESS {RVS}RETURN{ROFF} TO CONTINUE"
    360 GETC$:IFC$=""THEN360
    370 IFC$<>CHR$(13)GOTO360
    380 PRINT"OK"
    390 OPEN15,8,15
    400 REM SEEK
    410 JOB=176
    420 GOSUB650
    430 FORJ=0TO10
    440 FORI=0TO7
    450 READD
    460 D$(J)=D$(J)+CHR$(D)
    470 NEXTI
    480 NEXTJ
    490 I=0
    500 FORJ=0TO10
    510 PRINT#15,"M—W"CHR$(I)CHR$(5)CHR$(8)D$(J)
    520 I=I+8
    530 NEXTJ
    540 REM EXECUTE
    550 PRINT#15,"M-W"CHR$(2)CHR$(0)CHR$(1)CHR$(224)
    560 PRINT#15,"M—R"CHR$(2)CHR$(0)
    570 GET#15,E$
    580 IFE$=""THENE$=CHR$(0)
    590 E=ASC(E$)
    600 IFE>127GOTO560
    610 CLOSE15
    620 PRINT"{DOWN}DONE!"
    630 END
    640 REM JOB QUEUE
    650 TRY=0
    660 PRINT#15,"M-W"CHR$(8)CHR$(0)CHR$(4)CHR$(T)CHR$(S)CHR$(T)CHR$(S)
    670 PRINT#15,"M-W"CHR$(1)CHR$(0)CHR$(1)CHR$(JOB)
    680 TRY=TRY+1
    690 PRINT#15,"M-R"CHR$(1)CHR$(0)
    700 GET#15,E$
    710 IFE$=""THENE$=CHR$(0)
    720 E=ASC(E$)
    730 IFTRY=500GOTO760
    740 IFE>127GOTO680
    750 RETURN
    760 PRINT"{DOWN}FAILED"
    770 CLOSE15
    780 END
    790 REM DUPLICATE A SECTOR
    800 DATA 169,  4,133, 49, 32,143,247, 32
    810 DATA  16,245,162,  8, 80,254,184,202
    820 DATA 208,250,169,255,141,  3, 28,173
    830 DATA  12, 28, 41, 31,  9,192,141, 12
    840 DATA  28,169,255,162,  5,141,  1, 28
    850 DATA 184, 80,254,184,202,208,250,160
    860 DATA 187,185,  0,  1, 80,254,184,141
    870 DATA   1, 28,200,208,244,185,  0,  4
    880 DATA  80,254,184,141,  1, 28,200,208
    890 DATA 244, 80,254, 32,  0,254,169,  5
    900 DATA 133, 49,169,  1, 76,105,249,234

DUPLICATE A SINGLE SECTOR 23 ERROR SOURCE LISTING

    100 REM 23B.PAL
    110 REM
    120 0PEN2,8,2,"@0:23B.B,P,W"
    130 REM
    140 SYS40960
    150 ;
    160 .OPT P,02
    170 ;
    180 *= $0500
    190 ;
    200 LDA #$04
    210 STA $31
    220 ;
    230 JSR $F78F                      ; CONVERT TO GCR
    240 JSR $F510                      ; FIND HEADER #
    250 ;
    260 LDX #$08
    270 WAITGAP BVC WAITGAP            ; WAIT OUT GAP
    280 CLV
    290 DEX
    300 BNE WAITGAP
    310 ;
    320 LDA #$FF                       ; ENABLE WRITE
    330 STA $1C03
    340 LDA $1C0C
    350 AND #$1F
    360 ORA #$C0
    370 STA $1C0C
    380 LDA #$FF
    390 LDX #$05
    400 STA $1C01
    410 CLV
    420 WRITESYNC BVC WRITESYNC
    430 CLV
    440 DEX
    450 BNE WRITESYNC
    460 ;
    470 LDY #$BB
    480 OVERFLOW LDA $0100,Y           ; WRITE OUT OVERFLOW BUFFER
    490 WAIT1 BVC WAIT1
    500 CLV
    510 STA $1C01
    520 INY
    530 BNE OVERFLOW
    540 BUFFER LDA $0400,Y             ; WRITE OUT BUFFER
    550 WAIT2 BVC WAIT2
    560 CLV
    570 STA $1C01
    580 INY
    590 BNE BUFFER
    600 WAIT3 BVC WAIT3
    610 ;
    620 JSR $FE00                      ; ENABLE READ
    630 ;
    640 LDA #$05
    650 STA $31
    660 LDA #$01
    670 JMP $F969

Duplicate a Single Sector 23 Error Source Annotation

Identical to the 23A.PAL file with one exception. The checksum is left intact
after a corrupted data block is read from the master using the job queue. The
sector is stored at $0400-$04FF and the checksum at $003A. The checksum is
not recalculated or incremented. The entire sector and its checksum are
rewritten to the clone.

## 7.10 How to Create 23 Errors on a Full Track

Limitations: None.

Parameters: Track number.

FULL TRACK 23 ERROR

    100 REM 23M ERROR - 1541
    110 DIMD$(11)
    120 PRINT"{CLR}MULTIPLE 23 ERROR - 1541"
    130 PRINT"{DOWN}INSERT CLONE IN DRIVE"
    140 INPUT"{DOWN}DESTROY TRACK";T
    150 IFT<1ORT>35THENEND
    160 INPUT"{DOWN}ARE YOU SURE  Y{LEFT 3}";Q$
    170 IFQ$<>"Y"THENEND
    180 OPEN15,8,15
    190 PRINT#15,"I0"
    200 INPUT#15,EN$,EM$,ET$,ES$
    210 IFEN$="00"GOTO260
    220 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
    230 CLOSE15
    240 END
    250 REM SEEK
    260 JOB=176
    270 GOSUB580
    280 NS=20+2*(T>17)+(T>24)+(T>30)
    290 FORS=0TONS
    300 REM READ
    310 JOB=128
    320 GOSUB580
    330 IFS>0GOTO460
    340 FORJ=0TO11
    350 FORI=0TO7
    360 READD
    370 D$(J)=D$(J)+CHR$(D)
    380 NEXTI
    390 NEXTJ
    400 I=0
    410 FORJ=0TO11
    420 PRINT#15,"M-W"CHR$(I)CHR$(5)CHR$(8)D$(J)
    430 I=I+8
    440 NEXTJ
    450 REM EXECUTE
    460 PRINT"{HOME}{DOWN 8}{RVS}DESTROYING{ROFF} TRACK"T"- SECTOR"S
    470 PRINT#15,"M-W"CHR$(2)CHR$(0)CHR$(1)CHR$(224)
    480 PRINT#15,"M-R"CHR$(2)CHR$(0)
    490 GET#15,E$
    500 IFE$=""THENE$=CHR$(0)
    510 E=ASC(E$)
    520 IFE>127GOTO480
    530 NEXTS
    540 CLOSE15
    550 PRINT"{HOME}{DOWN 8}DONE!                         "
    560 END
    570 REM JOB QUEUE
    580 TRY=0
    590 PRINT#15,"M-W"CHR$(8)CHR$(0)CHR$(4)CHR$(T)CHR$(S)CHR$(T)CHR$(S)
    600 PRINT#15,"M-W"CHR$(1)CHR$(0)CHR$(1)CHR$(JOB)
    610 TRY=TRY+1
    620 PRINT#15,"M-R"CHR$(1)CHR$(0)
    630 GET#15,E$
    640 IFE$=""THENE$=CHR$(0)
    650 E=ASC(E$)
    660 IFTRY=500GOTO690
    670 IFE>127GOTO610
    680 RETURN
    690 CLOSE15
    700 PRINT"{DOWN}{RVS}FAILED{ROFF}"
    710 END
    720 REM 23 ERROR
    730 DATA 169,  4,133, 49,165, 58,170,232
    740 DATA 138,133, 58, 32,143,247, 32, 16
    750 DATA 245,162,  8, 80,254,184,202,208
    760 DATA 250,169,255,141,  3, 28,173, 12
    770 DATA  28, 41, 31,  9,192,141, 12, 28
    780 DATA 169,255,162,  5,141,  1, 28,184
    790 DATA  80,254,184,202,208,250,160,187
    800 DATA 185,  O,  1, 80,254,184,141,  1
    810 DATA  28,200,208,244,185,  O,  4, 80
    820 DATA 254,184,141,  1, 28,200,208,244
    830 DATA  80,254, 32,  0,254,169,  5,133
    840 DATA  49,169,  1,133,  2, 76,117,249

FULL TRACK 23 ERROR SOURCE LISTING

    100 REM 23M.PAL
    110 REM
    120 OPEN2,8,2,"@0:23M.B,P,W"
    130 REM
    140 SYS40960
    150 ;
    160 .OPT P,02
    170 ;
    180 *= $0500
    190 ;
    200 LDA #$04
    210 STA $31
    220 ;
    230 LDA $3A
    240 TAX
    250 INX                  ; INCREMENT CHECKSUM
    260 TXA
    270 STA $3A
    280 ;
    290 JSR $F78F            ; CONVERT TO GCR
    300 JSR $F510            ; FIND HEADER
    310 ;
    320 LDX #$08
    330 WAITGAP BVC WAITGAP  ; WAIT OUT GAP
    340 CLV
    350 DEX
    360 BNE WAITGAP
    370 ;
    380 LDA #$FF             ; ENABLE WRITE
    390 STA $1C03
    400 LDA $1C0C
    410 AND #$1F
    420 ORA #$C0
    430 STA $1C0C
    440 LDA #$FF
    450 LDX #$05
    460 STA $1C01
    470 CLV
    480 WRITESYNC BVC WRITESYNC
    490 CLV
    500 DEX
    510 BNE WRITESYNC
    520 ;
    530 LDY #$BB
    540 OVERFLOW LDA $0100,Y ; WRITE OUT OVERFLOW BUFFER
    550 WAIT1 BVC WAIT1
    560 CLV
    570 STA $1C01
    580 INY
    590 BNE OVERFLOW
    600 BUFFER LDA $0400,Y   ; WRITE OUT BUFFER
    610 WAIT2 BVC WAIT2
    620 CLV
    630 STA $1C01
    640 INY
    650 BNE BUFFER
    660 WAIT3 BVC WAIT3
    670 ;
    680 JSR $FE00            ; ENABLE READ
    690 ;
    700 LDA #$05
    710 STA $31
    720 LDA #$01
    730 STA $02
    740 JMP $F975

Full Track 23 Error Source Annotation

See the annotation for 23A.PAL. The BASIC driver loops to do all sectors on a
given track.

## 7.11 How to Create a 20 Error on a Single Sector

Limitations: Preceding sector must be intact (See the annotation for a single
sector 21 error).

Parameters: Track and sector number.

SINGLE SECTOR 20 ERROR

    100 REM 20 ERROR - 1541
    110 DIMD$(11)
    120 PRINT"{CLR}20 ERROR - 1541"
    130 PRINT"{DOWN}INSERT CLONE IN DRIVE"
    140 INPUT"{DOWN}DESTROY TRACK AND SECTOR (T,S)";T,S
    150 IFT<1ORT>35THENEND
    160 NS=20+2*(TM7)+(T>24)+(T>30)
    170 IFS<0ORS>NSTHENEND
    180 INPUT"{DOWN}ARE YOU SURE  Y{LEFT 3}";Q$
    190 IFQ$<>"Y"THENEND
    200 OPEN15,8,15
    210 PRINT#15,"I0"
    220 INPUT#15,EN$,EM$,ET$,ES$
    230 IFEN$="00"GOTO280
    240 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
    250 CLOSE15
    260 END
    270 REM SEEK
    280 IFS=0THENS=NS:GOTO300
    290 S=S-1
    300 JOB=176
    310 GOSUB570
    320 REM READ
    330 JOB=128
    340 GOSUB570
    350 FORJ=0TO11
    360 FORI=0TO7
    370 READD
    380 D$(J)=D$(J)+CHR$(D)
    390 NEXTI
    400 NEXTJ
    410 I=0
    420 FORJ=0TO11
    430 PRINT#15,"M-W"CHR$(I)CHR$(5)CHR$(8)D$(J)
    440 I=I+8
    450 NEXTJ
    460 REM EXECUTE
    470 PRINT#15,"M-W"CHR$(2)CHR$(0)CHR$(1)CHR$(224)
    480 PRINT#15,"M-R"CHR$(2)CHR$(0)
    490 GET#15,E$
    500 IFE$=""THENE$=CHR$(0)
    510 E=ASC(E$)
    520 IFE>127GOTO480
    530 CLOSE15
    540 PRINT"{DOWN}DONE!"
    550 END
    560 REM JOB QUEUE
    570 TRY=0
    580 PRINT#15,"M-W"CHR$(8)CHR$(0)CHR$(4)CHR$(T)CHR$(S)CHR$(T)CHR$(S)
    590 PRINT#15,"M-W"CHR$(1)CHR$(0)CHR$(1)CHR$(JOB)
    600 TRY=TRY+1
    610 PRINT#15,"M-R"CHR$(1)CHR$(0)
    620 GET#15,E$
    630 IFE$=""THENE$=CHR$(0)
    640 E=ASC(E$)
    650 IFTRY=500GOTO680
    660 IFE>127GOTO600
    670 IFE=1THENRETURN
    680 CLOSE15
    690 PRINT"{DOWN}{RVS}FAILED{ROFF}"
    700 END
    710 REM 20 ERROR
    720 DATA  32, 16,245, 32, 86,245,160, 20
    730 DATA 165, 25,201, 18,144, 12,136,136
    740 DATA 201, 25,144,  6,136,201, 31,144
    750 DATA   1,136,230, 24,197, 24,144,  6
    760 DATA 240,  4,169,  0,133, 25,169,  O
    770 DATA  69, 22, 69, 23, 69, 24, 69, 25
    780 DATA 133, 26, 32, 52,249, 32, 86,245
    790 DATA 169,255,141,  3, 28,173, 12, 28
    800 DATA  41, 31,  9,192,141, 12, 28,162
    810 DATA   0,181, 36, 80,254,184,141,  1
    820 DATA  28,232,224,  8,208,243, 80,254
    830 DATA  32,  0,254,169,  1, 76,105,249
    
SINGLE SECTOR 20 ERROR SOURCE LISTING

    100 REM 20.PAL
    110 REM
    120 OPEN2,8,2,"@0:20.B,P,W"
    130 REM
    140 SYS40960
    150 ;
    160 .OPT P,02
    170 ;
    180 *= $0500
    190 ;
    200 JSR $F510            ; FIND HEADER BLOCK
    210 JSR $F556            ; FIND DATA BLOCK
    220 ;
    230 LDY #$14
    240 LDA $19
    250 CMP #$12
    260 BCC ZONE
    270 DEY
    280 DEY
    290 CMP #$19
    300 BCC ZONE
    310 DEY
    320 CMP #$1F
    330 BCC ZONE
    340 DEY
    350 ZONE INC $18
    360 CMP $18
    370 BCC HEADER
    380 BEQ HEADER
    390 LDA #$00
    400 STA $19
    410 ;
    420 HEADER LDA #$00
    430 EOR $16
    440 EOR $17
    450 EOR $18
    460 EOR $19
    470 STA $1A
    480 ;
    490 JSR $F934            ; CREATE NEW HEADER# IMAGE
    500 JSR $F556            ; FIND HEADER BLOCK
    510 LDA #$FF
    520 STA $1C03
    530 LDA $1C0C
    540 AND #$1f
    550 ORA #$C0
    560 STA $1C0C
    570 LDX #$00
    580 WRITE LDA $0024,X
    590 WAIT1 BVC WAIT1
    600 CLV
    610 STA $1C01
    620 INX
    630 CPX #$08
    640 BNE WRITE
    650 WAIT2 BVC WAIT2
    660 ;
    670 JSR $FE00            ; READ MODE
    680 ;
    690 LDA #$01
    700 JMP $F969

Single Sector 20 Error Source Annotation

This routine represents a halfhearted attempt to rewrite a header. It is
dependent upon the preceding sector being intact. Lines 200-210 sync up to
the preceding header and data block. Lines 230-400 calculate the next sector
in the zone. A header image for the sector is created in RAM at $0024-$002C.
We sync up one more time which positions us to the start of the header block
we want to destroy. We flip to write mode and rewrite the header. We are
coming in just a shade too slow and create enough noise at the end of the
sync mark to destroy the actual header block identifier. (Tweaking the
internal clock reveals that the header was completely rewritten.) If the tail
gap was a constant length our task would be analogous to rewriting a sector
where the FDC syncs up to a header block, reads the header, and counts off
eight bytes. We would similarly sync up to a data block, count off 325 GCR
bytes, then count off the tail gap, and flip to write mode. However, it is
virtually impossible to gauge the length of the tail gap, so we're stuck.
Rest assured, though. It still gets the job done.

## 7.12 How to Create 20 Errors on a Full Track

Limitations: None.

Parameters: Track number.

FULL TRACK 20 ERROR

    100 REM 20M ERROR - 1541
    110 DIMD$(24)
    120 PRINT"{CLR}MULTIPLE 20 ERROR - 1541"
    130 PRINT"{DOWN}INSERT CLONE IN DRIVE"
    140 INPUT"{DOWN}DESTROY TRACK";T
    150 IFT<1ORT>35THENEND
    160 INPUT"{DOWN}ARE YOU SURE  Y{LEFT 3}";Q$
    170 IFQ$<>"Y"THENEND
    180 OPEN15,8,15
    190 PRINT#15,"I0"
    200 INPUT#15,EN$,EM$,ET$,ES$
    210 IFEN$="00"GOTO260
    220 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
    230 CLOSE15
    240 END
    250 REM SEEK
    260 NS=20+2*(T>17)+(T>24)+(T>30)
    270 S=NS
    280 J0B=176
    290 GOSUB580
    300 FORI=0TO23
    310 READD
    320 D$=D$+CHR$(D)
    330 I$=I$+CHR$(0)
    340 NEXTI
    350 PRINT#15,"M-W"CHR$(0)CHR$(6)CHR$(24)D$
    360 REM EXECUTE
    370 PRINT"{DOWN}{RVS}DESTROYING{ROFF} TRACK";T
    380 JOB=224
    390 GOSUB580
    400 PRINT#15,"M-W"CHR$(0)CHR$(6)CHR$(24)I$
    410 FORJ=0TO24
    420 FORI=0TO7
    430 READD
    440 D$(J)=D$(J)+CHR$(D)
    450 NEXTI
    460 NEXTJ
    470 I=0
    480 FORJ=0TO24
    490 PRINT#15,"M-W"CHR$(I)CHR$(4)CHR$(8)D$(J)
    500 I=I+8
    510 NEXTJ
    520 REM EXECUTE
    530 PRINT#15,"M-E"CHR$(0)CHR$(4)
    540 CLOSE15
    550 PRINT"{DOWN}DONE!"
    560 END
    570 REM JOB QUEUE
    580 TRY=0
    590 PRINT#15,"M-W"CHR$(12)CHR$(0)CHR$(2)CHR$(T)CHR$(S)
    600 PRINT#15,"M-W"CHR$(3)CHR$(0)CHR$(1)CHR$(JOB
    610 TRY=TRY+1
    620 PRINT#15,"M-R"CHR$(3)CHR$(0)
    630 GET#15,E$
    640 IFE$=""THENE$=CHR$(0)
    650 E=ASC(E$)
    660 IFTRY=500GOTO690
    670 IFE>127GOTO610
    680 RETURN
    690 CLOSE15
    700 PRINT"{DOWN}{RVS}FAILED{ROFF}"
    710 END
    720 REM 21 ERROR
    730 DATA  32,163,253,169, 85,141,  1, 28
    740 DATA 162,255,160, 48, 32,201,253, 32
    750 DATA   0,254,169,  1, 76,105,249,234
    760 REM 20M ERROR
    770 DATA169,  0,133,127,166, 12,134, 81
    780 DATA134,128,166, 13,232,134, 67,169
    790 DATA  1,141, 32,  6,169,  8,141, 38
    800 DATA  6,169,  0,141, 40,  6, 32,  0
    810 DATA193,162,  0,169,  9,157,  0,  3
    820 DATA232,232,173, 40,  6,157,  0,  3
    830 DATA232,165, 81,157,  0,  3,232,169
    840 DATA  0,157,  0,  3,232,157,  0,  3
    850 DATA232,169, 15,157,  0,  3,232,157
    860 DATA  0,  3,232,169,  0, 93,250,  2
    870 DATA 93,251,  2, 93,252,  2, 93,253
    880 DATA  2,157,249,  2,238, 40,  6,173
    890 DATA 40,  6,197, 67,208,189,138, 72
    900 DATA169, 75,141,  0,  5,162,  1,138
    910 DATA157,  0,  5,232,208,250,169,  0
    920 DATA133, 48,169,  3,133, 49, 32, 48 
    930 DATA254,104,168,136, 32,229,253, 32 
    940 DATA245,253,169,  5,133, 49, 32,233 
    950 DATA245,133, 58, 32,143,247,169, 35
    960 DATA133, 81,169,169,141,  0,  6,169
    970 DATA  5,141,  1,  6,169,133,141,  2
    980 DATA  6,169, 49,141,  3,  6,169, 76
    990 DATA141,  4,  6,169,170,141,  5,  6
    1000 DATA169,252,141,  6,  6,169,224,133
    1010 DATA  3,165,  3, 48,252, 76,148,193

FULL TRACK 20 ERROR SOURCE LISTING

    100 REM 20M.PAL
    110 REM
    120 OPE2,8,2,"@0:20M.B,P,W"
    130 REM
    140 SYS40960
    150 ;
    160 .OP P,02
    170 ;
    180 *= $0400
    190 ;
    200 ;* INITIALIZATION *
    210 ;
    220 LDA #$00
    230 STA $7F
    240 LDX $0C
    250 STX $51
    260 STX $80
    270 LDX $0D
    280 INX
    290 STX $43
    300 LDA #$01
    310 STA $0620
    320 LDA #$08             ; TAIL GAP
    330 STA $0626
    340 LDA #$00
    350 STA $0628            ; SECTOR COUNTER
    360 ;
    370 JSR $C100
    380 ;
    390 ;* CREATE HEADERS *
    400 ;
    410 LDX #$00
    420 HEADER LDA #$09      ; HBID
    430 STA $0300,X
    440 INX
    450 INX
    460 LDA $0628
    470 STA $0300,X          ; CHECKSUM
    480 INX
    490 LDA $51
    500 STA $0300,X          ; TRACK
    510 INX
    520 LDA #$00
    530 STA $0300,X          ; IDL
    540 INX
    550 STA $0300,X          ; IDH
    560 INX
    570 LDA #$0F
    580 STA $0300,X          ; GAP
    590 INX
    600 STA $0300,X          ; GAP
    610 INX
    620 ;
    630 LDA #$00
    640 EOR $02FA,X
    650 EOR $02FB,X
    660 EOR $02FC,X
    670 EOR $02FD,X
    680 EOR $02F9,X
    690 ;
    700 INC $0628
    710 LDA $0628
    720 CMP $43
    730 BNE HEADER
    740 ;
    750 TXA
    760 PHA
    770 ;
    780 ;* CREATE DATA *
    790 ;
    800 LDA #$4B            ; 1541 FORMAT
    810 STA $0500
    820 LDX #$01            ; 1541 FORMAT
    830 TXA
    840 DATA STA $0500,X
    850 INX
    860 BNE DATA
    870 ;
    880 ;* CONVERT TO GCR *
    890 ;
    900 LDA #$00
    910 STA $30
    920 LDA #$03
    930 STA $31
    940 JSR $FE30
    950 PLA
    960 TAY
    970 DEY
    980 JSR $FDE5
    990 JSR $FDE5
    1000 LDA #$05
    1010 STA $31
    1020 JSR $F5E9
    1030 STA $3A
    1040 JSR $F78F
    1050 ;
    1060 ;* JUMP INSTRUCTION 8
    1070 ;
    1080 LDA #$23
    1090 STA $51
    1100 ;
    1110 LDA #$A9
    1120 STA $0600
    1130 LDA #$05
    1140 STA $0601
    1150 LDA #$85
    1160 STA $0602
    1170 LDA #$31
    1180 STA $0603
    1190 LDA #$4C
    1200 STA $0604
    1210 LDA #$AA
    1220 STA $0605
    1230 LDA #$FC
    1240 STA $0606
    1250 ;
    1260 LDA #$E0
    1270 STA $03
    1280 ;
    1290 WAIT LDA $03
    1300 BMI WAIT
    1310 ;
    1320 JMP $C194
    
Full Track 20 Error Source Annotation    
    
This routine has a real surprise in store. Initialization in lines 220-290
sets the drive number to 0 ($007F) rather than rely on a default. The track
is read from the header table location $000C and stored at $0051. (Recall
that the driver set up the header table.) This memory location normally
contains an $FF at powerup to let the drive know that formatting has not yet
begun. We must reset it to the active track, or the drive will do a BUMP to
track one to start the format. Similarly, we read the sector range from
$000D, incremented this number to obtain a sector total for the track, and
stored it at $0043. Line 300 is our try counter. Normally the drive makes 10
attempts to format a single track. We either get it right the first time or
give up. (The driver erases the track as a safeguard.) We cannot allow the
FDC to reattempt to format the track because it will bypass our machine
language routine and re-enter the standard ROM routine. Lines 310-330
arbitrarily sets the tail gap to eight bytes in length. This avoids
duplicating 245 bytes of code from $FB1D to $FC12. RAM is at a dire premium
and we have neither the overhead nor the desire. 
    
Next we turn on the LED for cosmetic purposes (line 370) and build our header
table and a dummy data block (lines 410-860). We incremented the data block
identifier in line 420. Binary to GCR conversion is done in lines 900-1040.
Now for the jump instruction. First we reset the track number to 35 (lines
1080-1090) to let the FDC think that this is the last track of a normal
format. Why? We will be passing control to a standard ROM routine in a minute
and will let the FDC execute it. In other words, we are going to work the
6502 in both IP and FDC modes. Formatting is done as a single job; one track
at a time. When a track is formatted the FDC looks at $0051 to see if 35
tracks have been done. If not, it increments $0051 and does the next track as
another discrete job. The IP is going to wait for the FDC to reformat the
track and then retake control. We store the indirect buffer pointer to our
data block buffer and a jump to $FCAA at $0600. This ensures that the data
block will not be lost in the ensuing shuffle. We then set up the job queue
for an execute of buffer number 3 ($0600) and away we go. The IP monitors the
FDC while it is reformatting the track. (Not only that, but the FDC will
verify the track to ensure that it was reformatted incorrectly!) When bit
seven of the job code ($E0) goes low, the IP wrestles control away from the
FDC and jumps to ENDCMD ($C194) to terminate the routine. DOS ist gut!

## 7.13 How to Create 27 Errors on a Full Track

Limitations: None.

Parameters: Track number.

FULL TRACK 27 ERROR
    
    100 REM 27M ERROR - 1541
    110 DIMD$(25)
    120 PRINT"{CLR}MULTIPLE 27 ERROR - 1541"
    130 PRINT"{DOWN}INSERT CLONE IN DRIVE"
    140 INPUT"{DOWN}DESTROY TRACK";T
    150 IFT<1ORT>35THENEND
    160 INPUT"{DOWN}ARE YOU SURE  Y{LEFT 3}";Q$
    170 IFQ$<>"Y"THENEND
    180 OPEN15,8,15
    190 PRINT#15,"I0"
    200 INPUT#15,EN$,EM$,ET$,ES$
    210 IFEN$="00"GOTO260
    220 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
    230 CLOSE15
    240 END
    250 REM SEEK
    260 NS=20+2*(T>17)+(T>24)+(T>30)
    270 S=NS
    280 JOB=176
    290 GOSUB 580
    300 FORI=0TO23
    310 READD
    320 D$=D$+CHR$(D)
    330 I$=I$+CHR$(0)
    340 NEXTI
    350 PRINT#15,"M-W"CHR$(0)CHR$(6)CHR$(24)D$
    360 REM EXECUTE
    370 PRINT"{DOWN}{RVS}DESTROYING{ROFF} TRACK";T
    380 JOB=224
    390 GOSUB580
    400 PRINT#15,"M-W"CHR$(0)CHR$(6)CHR$(24)I$
    410 FORJ=0TO25
    420 FORI=0TO7
    430 READD
    440 D$(J)=D$(J)+CHR$(D)
    450 NEXTI
    460 NEXTJ
    470 I=0
    480 FORJ=0TO25
    490 PRINT#15,"M-W"CHR$(I)CHR$(4)CHR$(8)D$(J)
    500 I=I+8
    510 NEXTJ
    520 REM EXECUTE
    530 PRINT#15,"M-E"CHR$(0)CHR$(4)
    540 CLOSE15
    550 PRINT"{DOWN}DONE!"
    560 END
    570 REM JOB QUEUE
    580 TRY=0
    590 PRINT#15,"M-W"CHR$(12)CHR$(0)CHR$(2)CHR$(T)CHR$(S)
    600 PRINT#15,"M-W"CHR$(3)CHR$(0)CHR$(1)CHR$(JOB)
    610 TRY=TRY+1
    620 PRINT#15,"M-R"CHR$(3)CHR$(0)
    630 GET#15,E$
    640 IFE$=""THENE$=CHR$(0)
    650 E=ASC(E$)
    660 IFTRY=500GOTO690
    670 IFE>127GOTO610
    680 RETURN
    690 CLOSE15
    700 PRINT"{DOWN}{RVS}FAILED{ROFF}"
    710 END
    720 REM 21 ERROR
    730 DATA  32,163,253,169, 85,141,  1, 28
    740 DATA 162,255,160, 48, 32,201,253, 32
    750 DATA   0,254,169,  1, 76,105,249,234
    760 REM 27M ERROR
    770 DATA169,  0,133,127,166, 12,134, 81
    780 DATA134,128,166, 13,232,134, 67,169
    790 DATA  1,141, 32,  6,169,  8,141, 38
    800 DATA  6,169,  0,141, 40,  6, 32,  0
    810 DATA193,162,  0,169,  8,157,  0,  3
    820 DATA232,232,173, 40,  6,157,  0,  3
    830 DATA232,165, 81,157,  0,  3,232,169
    840 DATA  0,157,  0,  3,232,157,  0,  3
    850 DATA232,169, 15,157,  0,  3,232,157
    860 DATA  0,  3,232,169,  0, 93,250,  2
    870 DATA 93,251,  2, 93,252,  2, 93,253
    880 DATA  2,157,249,  2,254,249,  2,238
    890 DATA 40,  6,173, 40,  6,197, 67,208
    900 DATA186,138, 72,169, 75,141,  0,  5
    910 DATA162,  1,138,157,  0,  5,232,208
    920 DATA250,169,  0,133, 48,169,  3,133
    930 DATA 49, 32, 48,254,104,168,136, 32
    940 DATA229,253, 32,245,253,169,  5,133
    950 DATA 49, 32,233,245,133, 58, 32,143
    960 DATA247,169, 35,133, 81,169,169,141
    970 DATA  0,  6,169,  5,141,  1,  6,169
    980 DATA133,141,  2,  6,169, 49,141,  3
    990 DATA  6,169, 76,141,  4,  6,169,170
    1000 DATA141, 5,  6,169,252,141,  6,  6
    1010 DATA169,224,133,  3,165,  3, 48,252
    1020 DATA 76,148,193,234,234,234,234,234

FULL TRACK 27 SOURCE LISTING

    100 REM 27M.PAL
    110 REM
    120 OPEN2,8,2,"@0:27M.B,P,W"
    130 REM
    140 SYS40960
    150 ;
    160 .OPT P,02
    170 ;
    180 *= $0400
    190 ;
    200 ;* INITIALIZATION *
    210 ;
    220 LDA #$00
    230 STA $7F
    240 LDX $0C
    250 STX $51
    260 STX $80
    270 LDX $0D
    280 INX
    290 STX $43
    300 LDA #$01
    310 STA $0620
    320 LDA #$08             ; TAIL GAP
    330 STA $0626
    340 LDA #$00
    350 STA $0628            ; SECTOR COUNTER
    360 ;
    370 JSR $C100            ; LED ON
    380 ;
    390 ;* CREATE HEADERS *
    400 ;
    410 LDX #$00
    420 HEADER # LDA #$08    ; HBID
    430 STA $0300,X
    440 INX
    450 INX                  ; CHECKSUM
    460 LDA $0628
    470 STA $0300,X          ; SECTOR
    480 INX
    490 LDA $51
    500 STA $0300,X          ; TRACK
    510 INX
    520 LDA #$00
    530 STA $0300,X          ; IDL
    540 INX
    550 STA $0300,X          ; ODH
    560 INX
    570 LDA #$0F
    580 STA $0300,X          ; GAP
    590 INX
    600 STA $0300,X          ; GAP
    610 INX
    620 ;
    630 LDA #$00            ; COMPUTE CHECKSUM
    640 EOR $02FA,X
    650 EOR $02FB,X
    660 EOR $02FC,X
    670 EOR $02FD,X
    680 EOR $02F9,X
    690 ;
    700 INC $02F9,X         ; INCREMENT CHECKSUM
    710 ;
    720 INC $0628
    730 LDA $0628
    740 CMP $43
    750 BNE HEADER
    760 ;
    770 TXA
    780 PHA
    790 ;
    800 ;* CREATE DATA *
    810 ;
    820 LDA #$4B            ; 1541 FORMAT
    830 STA $0500
    840 LDX #$01            ; 1541 FORMAT
    850 TXA
    860 DATA STA $0500,X
    870 INX
    880 BNE DATA
    890 ;
    900 ;* CONVERT TO GCR *
    910 ;
    920 LDA #$00
    930 STA $30
    940 LDA #$03
    950 STA $31
    960 JSR $FE30
    970 PLA
    980 TAY
    990 DEY
    1000 JSR $FDE5
    1010 JSR $FDE5
    1020 LDA #$05
    1030 STA $31
    1040 JSR $F5E9
    1050 STA $3A
    1060 JSR $F78F
    1070 ;
    1080 ;* JUMP INSTRUCTION *
    1090 ;
    1100 LDA #$23
    1110 STA $51
    1120 ;
    1130 LDA #$A9
    1140 STA $0600
    1150 LDA #$05
    1160 STA $0601
    1170 LDA #$85
    1180 STA $06020
    1190 LDA #$31
    1200 STA $0603
    1210 LDA #$4C
    1220 STA $0604
    1230 LDA #$AA
    1240 STA $0605
    1250 LDA #$FC
    1260 STA $0606
    1270 ;
    1280 LDA #$E0
    1290 STA $03
    1300 ;
    1310 WAIT LDA $03
    1320 BMI WAIT
    1330 ;
    1340 JMP #C194

Full Track 27 Error Source Annotation

See the annotation for 20M.PAL. The only major difference is in line 700
above. Note the header block identifier ($08) in line 420 is left alone.

## 7.14 How to Create a 22 Error on a Single Sector

Limitations: None.

Parameters: Track and sector number.

SINGLE SECTOR 22 ERROR
    
    
    
    
    
    
    




    
    
    
    
    
    
    
    
    
    
    
    
    
    
    


-----------------------------------------------------Page 155-----------------------------------------------------
